// Code generated from qasm3Parser.g4 by ANTLR 4.10.1. DO NOT EDIT.

package parser // qasm3Parser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type qasm3Parser struct {
	*antlr.BaseParser
}

var qasm3parserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func qasm3parserParserInit() {
	staticData := &qasm3parserParserStaticData
	staticData.literalNames = []string{
		"", "'OPENQASM'", "'include'", "'defcalgrammar'", "'def'", "'cal'",
		"'defcal'", "'gate'", "'extern'", "'box'", "'let'", "'break'", "'continue'",
		"'if'", "'else'", "'end'", "'return'", "'for'", "'while'", "'in'", "",
		"", "'input'", "'output'", "'const'", "'mutable'", "'qreg'", "'qubit'",
		"'creg'", "'bool'", "'bit'", "'int'", "'uint'", "'float'", "'angle'",
		"'complex'", "'array'", "'duration'", "'stretch'", "'gphase'", "'inv'",
		"'pow'", "'ctrl'", "'negctrl'", "'#dim'", "'durationof'", "'delay'",
		"'reset'", "'measure'", "'barrier'", "", "'['", "']'", "'{'", "'}'",
		"'('", "')'", "':'", "';'", "'.'", "','", "'='", "'->'", "'+'", "'++'",
		"'-'", "'*'", "'**'", "'/'", "'%'", "'|'", "'||'", "'&'", "'&&'", "'^'",
		"'@'", "'~'", "'!'", "", "", "", "", "'im'",
	}
	staticData.symbolicNames = []string{
		"", "OPENQASM", "INCLUDE", "DEFCALGRAMMAR", "DEF", "CAL", "DEFCAL",
		"GATE", "EXTERN", "BOX", "LET", "BREAK", "CONTINUE", "IF", "ELSE", "END",
		"RETURN", "FOR", "WHILE", "IN", "PRAGMA", "AnnotationKeyword", "INPUT",
		"OUTPUT", "CONST", "MUTABLE", "QREG", "QUBIT", "CREG", "BOOL", "BIT",
		"INT", "UINT", "FLOAT", "ANGLE", "COMPLEX", "ARRAY", "DURATION", "STRETCH",
		"GPHASE", "INV", "POW", "CTRL", "NEGCTRL", "DIM", "DURATIONOF", "DELAY",
		"RESET", "MEASURE", "BARRIER", "BooleanLiteral", "LBRACKET", "RBRACKET",
		"LBRACE", "RBRACE", "LPAREN", "RPAREN", "COLON", "SEMICOLON", "DOT",
		"COMMA", "EQUALS", "ARROW", "PLUS", "DOUBLE_PLUS", "MINUS", "ASTERISK",
		"DOUBLE_ASTERISK", "SLASH", "PERCENT", "PIPE", "DOUBLE_PIPE", "AMPERSAND",
		"DOUBLE_AMPERSAND", "CARET", "AT", "TILDE", "EXCLAMATION_POINT", "EqualityOperator",
		"CompoundAssignmentOperator", "ComparisonOperator", "BitshiftOperator",
		"IMAG", "ImaginaryLiteral", "BinaryIntegerLiteral", "OctalIntegerLiteral",
		"DecimalIntegerLiteral", "HexIntegerLiteral", "Identifier", "HardwareQubit",
		"FloatLiteral", "TimingLiteral", "BitstringLiteral", "StringLiteral",
		"Whitespace", "Newline", "LineComment", "BlockComment", "VERSION_IDENTIFER_WHITESPACE",
		"VersionSpecifier", "EAT_INITIAL_SPACE", "EAT_LINE_END", "RemainingLineContent",
		"CAL_PRELUDE_WHITESPACE", "CAL_PRELUDE_COMMENT", "DEFCAL_PRELUDE_WHITESPACE",
		"DEFCAL_PRELUDE_COMMENT", "CalibrationBlock",
	}
	staticData.ruleNames = []string{
		"program", "version", "statement", "annotation", "scope", "pragma",
		"statementOrScope", "calibrationGrammarStatement", "includeStatement",
		"breakStatement", "continueStatement", "endStatement", "forStatement",
		"ifStatement", "returnStatement", "whileStatement", "barrierStatement",
		"boxStatement", "delayStatement", "gateCallStatement", "measureArrowAssignmentStatement",
		"resetStatement", "aliasDeclarationStatement", "classicalDeclarationStatement",
		"constDeclarationStatement", "ioDeclarationStatement", "oldStyleDeclarationStatement",
		"quantumDeclarationStatement", "defStatement", "externStatement", "gateStatement",
		"assignmentStatement", "expressionStatement", "calStatement", "defcalStatement",
		"expression", "aliasExpression", "declarationExpression", "measureExpression",
		"rangeExpression", "setExpression", "arrayLiteral", "indexOperator",
		"indexedIdentifier", "returnSignature", "gateModifier", "scalarType",
		"qubitType", "arrayType", "arrayReferenceType", "designator", "defcalTarget",
		"defcalArgumentDefinition", "defcalOperand", "gateOperand", "externArgument",
		"argumentDefinition", "argumentDefinitionList", "defcalArgumentDefinitionList",
		"defcalOperandList", "expressionList", "identifierList", "gateOperandList",
		"externArgumentList",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 107, 798, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 1, 0, 3, 0, 130, 8, 0, 1, 0, 5, 0, 133, 8, 0, 10, 0, 12, 0,
		136, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 5, 2, 146, 8,
		2, 10, 2, 12, 2, 149, 9, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 179, 8, 2, 3,
		2, 181, 8, 2, 1, 3, 1, 3, 3, 3, 185, 8, 3, 1, 4, 1, 4, 5, 4, 189, 8, 4,
		10, 4, 12, 4, 192, 9, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 3, 6,
		201, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9,
		1, 9, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 230, 8, 12, 1, 12,
		1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 241, 8,
		13, 1, 14, 1, 14, 1, 14, 3, 14, 246, 8, 14, 1, 14, 1, 14, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 3, 16, 258, 8, 16, 1, 16, 1,
		16, 1, 17, 1, 17, 3, 17, 264, 8, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18,
		3, 18, 271, 8, 18, 1, 18, 1, 18, 1, 19, 5, 19, 276, 8, 19, 10, 19, 12,
		19, 279, 9, 19, 1, 19, 1, 19, 1, 19, 3, 19, 284, 8, 19, 1, 19, 3, 19, 287,
		8, 19, 1, 19, 3, 19, 290, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 296,
		8, 19, 10, 19, 12, 19, 299, 9, 19, 1, 19, 1, 19, 1, 19, 3, 19, 304, 8,
		19, 1, 19, 3, 19, 307, 8, 19, 1, 19, 3, 19, 310, 8, 19, 1, 19, 3, 19, 313,
		8, 19, 1, 19, 3, 19, 316, 8, 19, 1, 20, 1, 20, 1, 20, 3, 20, 321, 8, 20,
		1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 23, 1, 23, 3, 23, 337, 8, 23, 1, 23, 1, 23, 1, 23, 3, 23,
		342, 8, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 25, 1, 25, 1, 25, 3, 25, 356, 8, 25, 1, 25, 1, 25, 1, 25, 1, 26,
		1, 26, 1, 26, 3, 26, 364, 8, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 376, 8, 28, 1, 28, 1, 28, 3, 28,
		380, 8, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 388, 8, 29,
		1, 29, 1, 29, 3, 29, 392, 8, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 400, 8, 30, 1, 30, 3, 30, 403, 8, 30, 1, 30, 1, 30, 1, 30, 1,
		31, 1, 31, 1, 31, 1, 31, 3, 31, 412, 8, 31, 1, 31, 1, 31, 1, 32, 1, 32,
		1, 32, 1, 33, 1, 33, 1, 33, 3, 33, 422, 8, 33, 1, 33, 1, 33, 1, 34, 1,
		34, 1, 34, 1, 34, 3, 34, 430, 8, 34, 1, 34, 3, 34, 433, 8, 34, 1, 34, 1,
		34, 3, 34, 437, 8, 34, 1, 34, 1, 34, 3, 34, 441, 8, 34, 1, 34, 1, 34, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 454,
		8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 3, 35, 468, 8, 35, 1, 35, 1, 35, 3, 35, 472, 8, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 5, 35, 509, 8, 35, 10, 35, 12, 35, 512, 9, 35, 1,
		36, 1, 36, 1, 36, 5, 36, 517, 8, 36, 10, 36, 12, 36, 520, 9, 36, 1, 37,
		1, 37, 1, 37, 3, 37, 525, 8, 37, 1, 38, 1, 38, 1, 38, 1, 39, 3, 39, 531,
		8, 39, 1, 39, 1, 39, 3, 39, 535, 8, 39, 1, 39, 1, 39, 3, 39, 539, 8, 39,
		1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 545, 8, 40, 10, 40, 12, 40, 548, 9,
		40, 1, 40, 3, 40, 551, 8, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 3, 41,
		558, 8, 41, 1, 41, 1, 41, 1, 41, 3, 41, 563, 8, 41, 5, 41, 565, 8, 41,
		10, 41, 12, 41, 568, 9, 41, 1, 41, 3, 41, 571, 8, 41, 1, 41, 1, 41, 1,
		42, 1, 42, 1, 42, 1, 42, 3, 42, 579, 8, 42, 1, 42, 1, 42, 1, 42, 3, 42,
		584, 8, 42, 5, 42, 586, 8, 42, 10, 42, 12, 42, 589, 9, 42, 1, 42, 3, 42,
		592, 8, 42, 3, 42, 594, 8, 42, 1, 42, 1, 42, 1, 43, 1, 43, 5, 43, 600,
		8, 43, 10, 43, 12, 43, 603, 9, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 619,
		8, 45, 3, 45, 621, 8, 45, 1, 45, 1, 45, 1, 46, 1, 46, 3, 46, 627, 8, 46,
		1, 46, 1, 46, 3, 46, 631, 8, 46, 1, 46, 1, 46, 3, 46, 635, 8, 46, 1, 46,
		1, 46, 3, 46, 639, 8, 46, 1, 46, 1, 46, 3, 46, 643, 8, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 653, 8, 46, 3, 46, 655,
		8, 46, 1, 47, 1, 47, 3, 47, 659, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 3, 49, 677, 8, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		51, 1, 51, 1, 52, 1, 52, 3, 52, 689, 8, 52, 1, 53, 1, 53, 1, 54, 1, 54,
		3, 54, 695, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 701, 8, 55, 3, 55,
		703, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 3, 56, 714, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 719, 8, 56, 1, 57, 1,
		57, 1, 57, 5, 57, 724, 8, 57, 10, 57, 12, 57, 727, 9, 57, 1, 57, 3, 57,
		730, 8, 57, 1, 58, 1, 58, 1, 58, 5, 58, 735, 8, 58, 10, 58, 12, 58, 738,
		9, 58, 1, 58, 3, 58, 741, 8, 58, 1, 59, 1, 59, 1, 59, 5, 59, 746, 8, 59,
		10, 59, 12, 59, 749, 9, 59, 1, 59, 3, 59, 752, 8, 59, 1, 60, 1, 60, 1,
		60, 5, 60, 757, 8, 60, 10, 60, 12, 60, 760, 9, 60, 1, 60, 3, 60, 763, 8,
		60, 1, 61, 1, 61, 1, 61, 5, 61, 768, 8, 61, 10, 61, 12, 61, 771, 9, 61,
		1, 61, 3, 61, 774, 8, 61, 1, 62, 1, 62, 1, 62, 5, 62, 779, 8, 62, 10, 62,
		12, 62, 782, 9, 62, 1, 62, 3, 62, 785, 8, 62, 1, 63, 1, 63, 1, 63, 5, 63,
		790, 8, 63, 10, 63, 12, 63, 793, 9, 63, 1, 63, 3, 63, 796, 8, 63, 1, 63,
		0, 1, 70, 64, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
		68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
		104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 0, 11, 1, 0,
		22, 23, 2, 0, 26, 26, 28, 28, 2, 0, 61, 61, 79, 79, 2, 0, 65, 65, 76, 77,
		2, 0, 50, 50, 83, 92, 2, 0, 66, 66, 68, 69, 2, 0, 63, 63, 65, 65, 1, 0,
		42, 43, 1, 0, 24, 25, 2, 0, 46, 48, 88, 88, 1, 0, 88, 89, 881, 0, 129,
		1, 0, 0, 0, 2, 139, 1, 0, 0, 0, 4, 180, 1, 0, 0, 0, 6, 182, 1, 0, 0, 0,
		8, 186, 1, 0, 0, 0, 10, 195, 1, 0, 0, 0, 12, 200, 1, 0, 0, 0, 14, 202,
		1, 0, 0, 0, 16, 206, 1, 0, 0, 0, 18, 210, 1, 0, 0, 0, 20, 213, 1, 0, 0,
		0, 22, 216, 1, 0, 0, 0, 24, 219, 1, 0, 0, 0, 26, 233, 1, 0, 0, 0, 28, 242,
		1, 0, 0, 0, 30, 249, 1, 0, 0, 0, 32, 255, 1, 0, 0, 0, 34, 261, 1, 0, 0,
		0, 36, 267, 1, 0, 0, 0, 38, 315, 1, 0, 0, 0, 40, 317, 1, 0, 0, 0, 42, 324,
		1, 0, 0, 0, 44, 328, 1, 0, 0, 0, 46, 336, 1, 0, 0, 0, 48, 345, 1, 0, 0,
		0, 50, 352, 1, 0, 0, 0, 52, 360, 1, 0, 0, 0, 54, 367, 1, 0, 0, 0, 56, 371,
		1, 0, 0, 0, 58, 383, 1, 0, 0, 0, 60, 395, 1, 0, 0, 0, 62, 407, 1, 0, 0,
		0, 64, 415, 1, 0, 0, 0, 66, 418, 1, 0, 0, 0, 68, 425, 1, 0, 0, 0, 70, 471,
		1, 0, 0, 0, 72, 513, 1, 0, 0, 0, 74, 524, 1, 0, 0, 0, 76, 526, 1, 0, 0,
		0, 78, 530, 1, 0, 0, 0, 80, 540, 1, 0, 0, 0, 82, 554, 1, 0, 0, 0, 84, 574,
		1, 0, 0, 0, 86, 597, 1, 0, 0, 0, 88, 604, 1, 0, 0, 0, 90, 620, 1, 0, 0,
		0, 92, 654, 1, 0, 0, 0, 94, 656, 1, 0, 0, 0, 96, 660, 1, 0, 0, 0, 98, 667,
		1, 0, 0, 0, 100, 680, 1, 0, 0, 0, 102, 684, 1, 0, 0, 0, 104, 688, 1, 0,
		0, 0, 106, 690, 1, 0, 0, 0, 108, 694, 1, 0, 0, 0, 110, 702, 1, 0, 0, 0,
		112, 718, 1, 0, 0, 0, 114, 720, 1, 0, 0, 0, 116, 731, 1, 0, 0, 0, 118,
		742, 1, 0, 0, 0, 120, 753, 1, 0, 0, 0, 122, 764, 1, 0, 0, 0, 124, 775,
		1, 0, 0, 0, 126, 786, 1, 0, 0, 0, 128, 130, 3, 2, 1, 0, 129, 128, 1, 0,
		0, 0, 129, 130, 1, 0, 0, 0, 130, 134, 1, 0, 0, 0, 131, 133, 3, 4, 2, 0,
		132, 131, 1, 0, 0, 0, 133, 136, 1, 0, 0, 0, 134, 132, 1, 0, 0, 0, 134,
		135, 1, 0, 0, 0, 135, 137, 1, 0, 0, 0, 136, 134, 1, 0, 0, 0, 137, 138,
		5, 0, 0, 1, 138, 1, 1, 0, 0, 0, 139, 140, 5, 1, 0, 0, 140, 141, 5, 99,
		0, 0, 141, 142, 5, 58, 0, 0, 142, 3, 1, 0, 0, 0, 143, 181, 3, 10, 5, 0,
		144, 146, 3, 6, 3, 0, 145, 144, 1, 0, 0, 0, 146, 149, 1, 0, 0, 0, 147,
		145, 1, 0, 0, 0, 147, 148, 1, 0, 0, 0, 148, 178, 1, 0, 0, 0, 149, 147,
		1, 0, 0, 0, 150, 179, 3, 44, 22, 0, 151, 179, 3, 62, 31, 0, 152, 179, 3,
		32, 16, 0, 153, 179, 3, 34, 17, 0, 154, 179, 3, 18, 9, 0, 155, 179, 3,
		66, 33, 0, 156, 179, 3, 14, 7, 0, 157, 179, 3, 46, 23, 0, 158, 179, 3,
		48, 24, 0, 159, 179, 3, 20, 10, 0, 160, 179, 3, 56, 28, 0, 161, 179, 3,
		68, 34, 0, 162, 179, 3, 36, 18, 0, 163, 179, 3, 22, 11, 0, 164, 179, 3,
		64, 32, 0, 165, 179, 3, 58, 29, 0, 166, 179, 3, 24, 12, 0, 167, 179, 3,
		38, 19, 0, 168, 179, 3, 60, 30, 0, 169, 179, 3, 26, 13, 0, 170, 179, 3,
		16, 8, 0, 171, 179, 3, 50, 25, 0, 172, 179, 3, 40, 20, 0, 173, 179, 3,
		52, 26, 0, 174, 179, 3, 54, 27, 0, 175, 179, 3, 42, 21, 0, 176, 179, 3,
		28, 14, 0, 177, 179, 3, 30, 15, 0, 178, 150, 1, 0, 0, 0, 178, 151, 1, 0,
		0, 0, 178, 152, 1, 0, 0, 0, 178, 153, 1, 0, 0, 0, 178, 154, 1, 0, 0, 0,
		178, 155, 1, 0, 0, 0, 178, 156, 1, 0, 0, 0, 178, 157, 1, 0, 0, 0, 178,
		158, 1, 0, 0, 0, 178, 159, 1, 0, 0, 0, 178, 160, 1, 0, 0, 0, 178, 161,
		1, 0, 0, 0, 178, 162, 1, 0, 0, 0, 178, 163, 1, 0, 0, 0, 178, 164, 1, 0,
		0, 0, 178, 165, 1, 0, 0, 0, 178, 166, 1, 0, 0, 0, 178, 167, 1, 0, 0, 0,
		178, 168, 1, 0, 0, 0, 178, 169, 1, 0, 0, 0, 178, 170, 1, 0, 0, 0, 178,
		171, 1, 0, 0, 0, 178, 172, 1, 0, 0, 0, 178, 173, 1, 0, 0, 0, 178, 174,
		1, 0, 0, 0, 178, 175, 1, 0, 0, 0, 178, 176, 1, 0, 0, 0, 178, 177, 1, 0,
		0, 0, 179, 181, 1, 0, 0, 0, 180, 143, 1, 0, 0, 0, 180, 147, 1, 0, 0, 0,
		181, 5, 1, 0, 0, 0, 182, 184, 5, 21, 0, 0, 183, 185, 5, 102, 0, 0, 184,
		183, 1, 0, 0, 0, 184, 185, 1, 0, 0, 0, 185, 7, 1, 0, 0, 0, 186, 190, 5,
		53, 0, 0, 187, 189, 3, 4, 2, 0, 188, 187, 1, 0, 0, 0, 189, 192, 1, 0, 0,
		0, 190, 188, 1, 0, 0, 0, 190, 191, 1, 0, 0, 0, 191, 193, 1, 0, 0, 0, 192,
		190, 1, 0, 0, 0, 193, 194, 5, 54, 0, 0, 194, 9, 1, 0, 0, 0, 195, 196, 5,
		20, 0, 0, 196, 197, 5, 102, 0, 0, 197, 11, 1, 0, 0, 0, 198, 201, 3, 4,
		2, 0, 199, 201, 3, 8, 4, 0, 200, 198, 1, 0, 0, 0, 200, 199, 1, 0, 0, 0,
		201, 13, 1, 0, 0, 0, 202, 203, 5, 3, 0, 0, 203, 204, 5, 93, 0, 0, 204,
		205, 5, 58, 0, 0, 205, 15, 1, 0, 0, 0, 206, 207, 5, 2, 0, 0, 207, 208,
		5, 93, 0, 0, 208, 209, 5, 58, 0, 0, 209, 17, 1, 0, 0, 0, 210, 211, 5, 11,
		0, 0, 211, 212, 5, 58, 0, 0, 212, 19, 1, 0, 0, 0, 213, 214, 5, 12, 0, 0,
		214, 215, 5, 58, 0, 0, 215, 21, 1, 0, 0, 0, 216, 217, 5, 15, 0, 0, 217,
		218, 5, 58, 0, 0, 218, 23, 1, 0, 0, 0, 219, 220, 5, 17, 0, 0, 220, 221,
		3, 92, 46, 0, 221, 222, 5, 88, 0, 0, 222, 229, 5, 19, 0, 0, 223, 230, 3,
		80, 40, 0, 224, 225, 5, 51, 0, 0, 225, 226, 3, 78, 39, 0, 226, 227, 5,
		52, 0, 0, 227, 230, 1, 0, 0, 0, 228, 230, 5, 88, 0, 0, 229, 223, 1, 0,
		0, 0, 229, 224, 1, 0, 0, 0, 229, 228, 1, 0, 0, 0, 230, 231, 1, 0, 0, 0,
		231, 232, 3, 12, 6, 0, 232, 25, 1, 0, 0, 0, 233, 234, 5, 13, 0, 0, 234,
		235, 5, 55, 0, 0, 235, 236, 3, 70, 35, 0, 236, 237, 5, 56, 0, 0, 237, 240,
		3, 12, 6, 0, 238, 239, 5, 14, 0, 0, 239, 241, 3, 12, 6, 0, 240, 238, 1,
		0, 0, 0, 240, 241, 1, 0, 0, 0, 241, 27, 1, 0, 0, 0, 242, 245, 5, 16, 0,
		0, 243, 246, 3, 70, 35, 0, 244, 246, 3, 76, 38, 0, 245, 243, 1, 0, 0, 0,
		245, 244, 1, 0, 0, 0, 245, 246, 1, 0, 0, 0, 246, 247, 1, 0, 0, 0, 247,
		248, 5, 58, 0, 0, 248, 29, 1, 0, 0, 0, 249, 250, 5, 18, 0, 0, 250, 251,
		5, 55, 0, 0, 251, 252, 3, 70, 35, 0, 252, 253, 5, 56, 0, 0, 253, 254, 3,
		12, 6, 0, 254, 31, 1, 0, 0, 0, 255, 257, 5, 49, 0, 0, 256, 258, 3, 124,
		62, 0, 257, 256, 1, 0, 0, 0, 257, 258, 1, 0, 0, 0, 258, 259, 1, 0, 0, 0,
		259, 260, 5, 58, 0, 0, 260, 33, 1, 0, 0, 0, 261, 263, 5, 9, 0, 0, 262,
		264, 3, 100, 50, 0, 263, 262, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 265,
		1, 0, 0, 0, 265, 266, 3, 8, 4, 0, 266, 35, 1, 0, 0, 0, 267, 268, 5, 46,
		0, 0, 268, 270, 3, 100, 50, 0, 269, 271, 3, 124, 62, 0, 270, 269, 1, 0,
		0, 0, 270, 271, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272, 273, 5, 58, 0, 0,
		273, 37, 1, 0, 0, 0, 274, 276, 3, 90, 45, 0, 275, 274, 1, 0, 0, 0, 276,
		279, 1, 0, 0, 0, 277, 275, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 280,
		1, 0, 0, 0, 279, 277, 1, 0, 0, 0, 280, 286, 5, 88, 0, 0, 281, 283, 5, 55,
		0, 0, 282, 284, 3, 120, 60, 0, 283, 282, 1, 0, 0, 0, 283, 284, 1, 0, 0,
		0, 284, 285, 1, 0, 0, 0, 285, 287, 5, 56, 0, 0, 286, 281, 1, 0, 0, 0, 286,
		287, 1, 0, 0, 0, 287, 289, 1, 0, 0, 0, 288, 290, 3, 100, 50, 0, 289, 288,
		1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290, 291, 1, 0, 0, 0, 291, 292, 3, 124,
		62, 0, 292, 293, 5, 58, 0, 0, 293, 316, 1, 0, 0, 0, 294, 296, 3, 90, 45,
		0, 295, 294, 1, 0, 0, 0, 296, 299, 1, 0, 0, 0, 297, 295, 1, 0, 0, 0, 297,
		298, 1, 0, 0, 0, 298, 300, 1, 0, 0, 0, 299, 297, 1, 0, 0, 0, 300, 306,
		5, 39, 0, 0, 301, 303, 5, 55, 0, 0, 302, 304, 3, 120, 60, 0, 303, 302,
		1, 0, 0, 0, 303, 304, 1, 0, 0, 0, 304, 305, 1, 0, 0, 0, 305, 307, 5, 56,
		0, 0, 306, 301, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307, 309, 1, 0, 0, 0,
		308, 310, 3, 100, 50, 0, 309, 308, 1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310,
		312, 1, 0, 0, 0, 311, 313, 3, 124, 62, 0, 312, 311, 1, 0, 0, 0, 312, 313,
		1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 316, 5, 58, 0, 0, 315, 277, 1, 0,
		0, 0, 315, 297, 1, 0, 0, 0, 316, 39, 1, 0, 0, 0, 317, 320, 3, 76, 38, 0,
		318, 319, 5, 62, 0, 0, 319, 321, 3, 86, 43, 0, 320, 318, 1, 0, 0, 0, 320,
		321, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 323, 5, 58, 0, 0, 323, 41,
		1, 0, 0, 0, 324, 325, 5, 47, 0, 0, 325, 326, 3, 108, 54, 0, 326, 327, 5,
		58, 0, 0, 327, 43, 1, 0, 0, 0, 328, 329, 5, 10, 0, 0, 329, 330, 5, 88,
		0, 0, 330, 331, 5, 61, 0, 0, 331, 332, 3, 72, 36, 0, 332, 333, 5, 58, 0,
		0, 333, 45, 1, 0, 0, 0, 334, 337, 3, 92, 46, 0, 335, 337, 3, 96, 48, 0,
		336, 334, 1, 0, 0, 0, 336, 335, 1, 0, 0, 0, 337, 338, 1, 0, 0, 0, 338,
		341, 5, 88, 0, 0, 339, 340, 5, 61, 0, 0, 340, 342, 3, 74, 37, 0, 341, 339,
		1, 0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343, 344, 5, 58,
		0, 0, 344, 47, 1, 0, 0, 0, 345, 346, 5, 24, 0, 0, 346, 347, 3, 92, 46,
		0, 347, 348, 5, 88, 0, 0, 348, 349, 5, 61, 0, 0, 349, 350, 3, 74, 37, 0,
		350, 351, 5, 58, 0, 0, 351, 49, 1, 0, 0, 0, 352, 355, 7, 0, 0, 0, 353,
		356, 3, 92, 46, 0, 354, 356, 3, 96, 48, 0, 355, 353, 1, 0, 0, 0, 355, 354,
		1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 358, 5, 88, 0, 0, 358, 359, 5, 58,
		0, 0, 359, 51, 1, 0, 0, 0, 360, 361, 7, 1, 0, 0, 361, 363, 5, 88, 0, 0,
		362, 364, 3, 100, 50, 0, 363, 362, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364,
		365, 1, 0, 0, 0, 365, 366, 5, 58, 0, 0, 366, 53, 1, 0, 0, 0, 367, 368,
		3, 94, 47, 0, 368, 369, 5, 88, 0, 0, 369, 370, 5, 58, 0, 0, 370, 55, 1,
		0, 0, 0, 371, 372, 5, 4, 0, 0, 372, 373, 5, 88, 0, 0, 373, 375, 5, 55,
		0, 0, 374, 376, 3, 114, 57, 0, 375, 374, 1, 0, 0, 0, 375, 376, 1, 0, 0,
		0, 376, 377, 1, 0, 0, 0, 377, 379, 5, 56, 0, 0, 378, 380, 3, 88, 44, 0,
		379, 378, 1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380, 381, 1, 0, 0, 0, 381,
		382, 3, 8, 4, 0, 382, 57, 1, 0, 0, 0, 383, 384, 5, 8, 0, 0, 384, 385, 5,
		88, 0, 0, 385, 387, 5, 55, 0, 0, 386, 388, 3, 126, 63, 0, 387, 386, 1,
		0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 389, 1, 0, 0, 0, 389, 391, 5, 56, 0,
		0, 390, 392, 3, 88, 44, 0, 391, 390, 1, 0, 0, 0, 391, 392, 1, 0, 0, 0,
		392, 393, 1, 0, 0, 0, 393, 394, 5, 58, 0, 0, 394, 59, 1, 0, 0, 0, 395,
		396, 5, 7, 0, 0, 396, 402, 5, 88, 0, 0, 397, 399, 5, 55, 0, 0, 398, 400,
		3, 122, 61, 0, 399, 398, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 401, 1,
		0, 0, 0, 401, 403, 5, 56, 0, 0, 402, 397, 1, 0, 0, 0, 402, 403, 1, 0, 0,
		0, 403, 404, 1, 0, 0, 0, 404, 405, 3, 122, 61, 0, 405, 406, 3, 8, 4, 0,
		406, 61, 1, 0, 0, 0, 407, 408, 3, 86, 43, 0, 408, 411, 7, 2, 0, 0, 409,
		412, 3, 70, 35, 0, 410, 412, 3, 76, 38, 0, 411, 409, 1, 0, 0, 0, 411, 410,
		1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 414, 5, 58, 0, 0, 414, 63, 1, 0,
		0, 0, 415, 416, 3, 70, 35, 0, 416, 417, 5, 58, 0, 0, 417, 65, 1, 0, 0,
		0, 418, 419, 5, 5, 0, 0, 419, 421, 5, 53, 0, 0, 420, 422, 5, 107, 0, 0,
		421, 420, 1, 0, 0, 0, 421, 422, 1, 0, 0, 0, 422, 423, 1, 0, 0, 0, 423,
		424, 5, 54, 0, 0, 424, 67, 1, 0, 0, 0, 425, 426, 5, 6, 0, 0, 426, 432,
		3, 102, 51, 0, 427, 429, 5, 55, 0, 0, 428, 430, 3, 116, 58, 0, 429, 428,
		1, 0, 0, 0, 429, 430, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 433, 5, 56,
		0, 0, 432, 427, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 434, 1, 0, 0, 0,
		434, 436, 3, 118, 59, 0, 435, 437, 3, 88, 44, 0, 436, 435, 1, 0, 0, 0,
		436, 437, 1, 0, 0, 0, 437, 438, 1, 0, 0, 0, 438, 440, 5, 53, 0, 0, 439,
		441, 5, 107, 0, 0, 440, 439, 1, 0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 442,
		1, 0, 0, 0, 442, 443, 5, 54, 0, 0, 443, 69, 1, 0, 0, 0, 444, 445, 6, 35,
		-1, 0, 445, 446, 5, 55, 0, 0, 446, 447, 3, 70, 35, 0, 447, 448, 5, 56,
		0, 0, 448, 472, 1, 0, 0, 0, 449, 450, 7, 3, 0, 0, 450, 472, 3, 70, 35,
		15, 451, 454, 3, 92, 46, 0, 452, 454, 3, 96, 48, 0, 453, 451, 1, 0, 0,
		0, 453, 452, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 456, 5, 55, 0, 0, 456,
		457, 3, 70, 35, 0, 457, 458, 5, 56, 0, 0, 458, 472, 1, 0, 0, 0, 459, 460,
		5, 45, 0, 0, 460, 461, 5, 55, 0, 0, 461, 462, 3, 8, 4, 0, 462, 463, 5,
		56, 0, 0, 463, 472, 1, 0, 0, 0, 464, 465, 5, 88, 0, 0, 465, 467, 5, 55,
		0, 0, 466, 468, 3, 120, 60, 0, 467, 466, 1, 0, 0, 0, 467, 468, 1, 0, 0,
		0, 468, 469, 1, 0, 0, 0, 469, 472, 5, 56, 0, 0, 470, 472, 7, 4, 0, 0, 471,
		444, 1, 0, 0, 0, 471, 449, 1, 0, 0, 0, 471, 453, 1, 0, 0, 0, 471, 459,
		1, 0, 0, 0, 471, 464, 1, 0, 0, 0, 471, 470, 1, 0, 0, 0, 472, 510, 1, 0,
		0, 0, 473, 474, 10, 16, 0, 0, 474, 475, 5, 67, 0, 0, 475, 509, 3, 70, 35,
		16, 476, 477, 10, 14, 0, 0, 477, 478, 7, 5, 0, 0, 478, 509, 3, 70, 35,
		15, 479, 480, 10, 13, 0, 0, 480, 481, 7, 6, 0, 0, 481, 509, 3, 70, 35,
		14, 482, 483, 10, 12, 0, 0, 483, 484, 5, 81, 0, 0, 484, 509, 3, 70, 35,
		13, 485, 486, 10, 11, 0, 0, 486, 487, 5, 80, 0, 0, 487, 509, 3, 70, 35,
		12, 488, 489, 10, 10, 0, 0, 489, 490, 5, 78, 0, 0, 490, 509, 3, 70, 35,
		11, 491, 492, 10, 9, 0, 0, 492, 493, 5, 72, 0, 0, 493, 509, 3, 70, 35,
		10, 494, 495, 10, 8, 0, 0, 495, 496, 5, 74, 0, 0, 496, 509, 3, 70, 35,
		9, 497, 498, 10, 7, 0, 0, 498, 499, 5, 70, 0, 0, 499, 509, 3, 70, 35, 8,
		500, 501, 10, 6, 0, 0, 501, 502, 5, 73, 0, 0, 502, 509, 3, 70, 35, 7, 503,
		504, 10, 5, 0, 0, 504, 505, 5, 71, 0, 0, 505, 509, 3, 70, 35, 6, 506, 507,
		10, 17, 0, 0, 507, 509, 3, 84, 42, 0, 508, 473, 1, 0, 0, 0, 508, 476, 1,
		0, 0, 0, 508, 479, 1, 0, 0, 0, 508, 482, 1, 0, 0, 0, 508, 485, 1, 0, 0,
		0, 508, 488, 1, 0, 0, 0, 508, 491, 1, 0, 0, 0, 508, 494, 1, 0, 0, 0, 508,
		497, 1, 0, 0, 0, 508, 500, 1, 0, 0, 0, 508, 503, 1, 0, 0, 0, 508, 506,
		1, 0, 0, 0, 509, 512, 1, 0, 0, 0, 510, 508, 1, 0, 0, 0, 510, 511, 1, 0,
		0, 0, 511, 71, 1, 0, 0, 0, 512, 510, 1, 0, 0, 0, 513, 518, 3, 70, 35, 0,
		514, 515, 5, 64, 0, 0, 515, 517, 3, 70, 35, 0, 516, 514, 1, 0, 0, 0, 517,
		520, 1, 0, 0, 0, 518, 516, 1, 0, 0, 0, 518, 519, 1, 0, 0, 0, 519, 73, 1,
		0, 0, 0, 520, 518, 1, 0, 0, 0, 521, 525, 3, 82, 41, 0, 522, 525, 3, 70,
		35, 0, 523, 525, 3, 76, 38, 0, 524, 521, 1, 0, 0, 0, 524, 522, 1, 0, 0,
		0, 524, 523, 1, 0, 0, 0, 525, 75, 1, 0, 0, 0, 526, 527, 5, 48, 0, 0, 527,
		528, 3, 108, 54, 0, 528, 77, 1, 0, 0, 0, 529, 531, 3, 70, 35, 0, 530, 529,
		1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532, 534, 5, 57,
		0, 0, 533, 535, 3, 70, 35, 0, 534, 533, 1, 0, 0, 0, 534, 535, 1, 0, 0,
		0, 535, 538, 1, 0, 0, 0, 536, 537, 5, 57, 0, 0, 537, 539, 3, 70, 35, 0,
		538, 536, 1, 0, 0, 0, 538, 539, 1, 0, 0, 0, 539, 79, 1, 0, 0, 0, 540, 541,
		5, 53, 0, 0, 541, 546, 3, 70, 35, 0, 542, 543, 5, 60, 0, 0, 543, 545, 3,
		70, 35, 0, 544, 542, 1, 0, 0, 0, 545, 548, 1, 0, 0, 0, 546, 544, 1, 0,
		0, 0, 546, 547, 1, 0, 0, 0, 547, 550, 1, 0, 0, 0, 548, 546, 1, 0, 0, 0,
		549, 551, 5, 60, 0, 0, 550, 549, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551,
		552, 1, 0, 0, 0, 552, 553, 5, 54, 0, 0, 553, 81, 1, 0, 0, 0, 554, 557,
		5, 53, 0, 0, 555, 558, 3, 70, 35, 0, 556, 558, 3, 82, 41, 0, 557, 555,
		1, 0, 0, 0, 557, 556, 1, 0, 0, 0, 558, 566, 1, 0, 0, 0, 559, 562, 5, 60,
		0, 0, 560, 563, 3, 70, 35, 0, 561, 563, 3, 82, 41, 0, 562, 560, 1, 0, 0,
		0, 562, 561, 1, 0, 0, 0, 563, 565, 1, 0, 0, 0, 564, 559, 1, 0, 0, 0, 565,
		568, 1, 0, 0, 0, 566, 564, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 570,
		1, 0, 0, 0, 568, 566, 1, 0, 0, 0, 569, 571, 5, 60, 0, 0, 570, 569, 1, 0,
		0, 0, 570, 571, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 573, 5, 54, 0, 0,
		573, 83, 1, 0, 0, 0, 574, 593, 5, 51, 0, 0, 575, 594, 3, 80, 40, 0, 576,
		579, 3, 70, 35, 0, 577, 579, 3, 78, 39, 0, 578, 576, 1, 0, 0, 0, 578, 577,
		1, 0, 0, 0, 579, 587, 1, 0, 0, 0, 580, 583, 5, 60, 0, 0, 581, 584, 3, 70,
		35, 0, 582, 584, 3, 78, 39, 0, 583, 581, 1, 0, 0, 0, 583, 582, 1, 0, 0,
		0, 584, 586, 1, 0, 0, 0, 585, 580, 1, 0, 0, 0, 586, 589, 1, 0, 0, 0, 587,
		585, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 591, 1, 0, 0, 0, 589, 587,
		1, 0, 0, 0, 590, 592, 5, 60, 0, 0, 591, 590, 1, 0, 0, 0, 591, 592, 1, 0,
		0, 0, 592, 594, 1, 0, 0, 0, 593, 575, 1, 0, 0, 0, 593, 578, 1, 0, 0, 0,
		594, 595, 1, 0, 0, 0, 595, 596, 5, 52, 0, 0, 596, 85, 1, 0, 0, 0, 597,
		601, 5, 88, 0, 0, 598, 600, 3, 84, 42, 0, 599, 598, 1, 0, 0, 0, 600, 603,
		1, 0, 0, 0, 601, 599, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0, 602, 87, 1, 0,
		0, 0, 603, 601, 1, 0, 0, 0, 604, 605, 5, 62, 0, 0, 605, 606, 3, 92, 46,
		0, 606, 89, 1, 0, 0, 0, 607, 621, 5, 40, 0, 0, 608, 609, 5, 41, 0, 0, 609,
		610, 5, 55, 0, 0, 610, 611, 3, 70, 35, 0, 611, 612, 5, 56, 0, 0, 612, 621,
		1, 0, 0, 0, 613, 618, 7, 7, 0, 0, 614, 615, 5, 55, 0, 0, 615, 616, 3, 70,
		35, 0, 616, 617, 5, 56, 0, 0, 617, 619, 1, 0, 0, 0, 618, 614, 1, 0, 0,
		0, 618, 619, 1, 0, 0, 0, 619, 621, 1, 0, 0, 0, 620, 607, 1, 0, 0, 0, 620,
		608, 1, 0, 0, 0, 620, 613, 1, 0, 0, 0, 621, 622, 1, 0, 0, 0, 622, 623,
		5, 75, 0, 0, 623, 91, 1, 0, 0, 0, 624, 626, 5, 30, 0, 0, 625, 627, 3, 100,
		50, 0, 626, 625, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 655, 1, 0, 0, 0,
		628, 630, 5, 31, 0, 0, 629, 631, 3, 100, 50, 0, 630, 629, 1, 0, 0, 0, 630,
		631, 1, 0, 0, 0, 631, 655, 1, 0, 0, 0, 632, 634, 5, 32, 0, 0, 633, 635,
		3, 100, 50, 0, 634, 633, 1, 0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 655, 1,
		0, 0, 0, 636, 638, 5, 33, 0, 0, 637, 639, 3, 100, 50, 0, 638, 637, 1, 0,
		0, 0, 638, 639, 1, 0, 0, 0, 639, 655, 1, 0, 0, 0, 640, 642, 5, 34, 0, 0,
		641, 643, 3, 100, 50, 0, 642, 641, 1, 0, 0, 0, 642, 643, 1, 0, 0, 0, 643,
		655, 1, 0, 0, 0, 644, 655, 5, 29, 0, 0, 645, 655, 5, 37, 0, 0, 646, 655,
		5, 38, 0, 0, 647, 652, 5, 35, 0, 0, 648, 649, 5, 51, 0, 0, 649, 650, 3,
		92, 46, 0, 650, 651, 5, 52, 0, 0, 651, 653, 1, 0, 0, 0, 652, 648, 1, 0,
		0, 0, 652, 653, 1, 0, 0, 0, 653, 655, 1, 0, 0, 0, 654, 624, 1, 0, 0, 0,
		654, 628, 1, 0, 0, 0, 654, 632, 1, 0, 0, 0, 654, 636, 1, 0, 0, 0, 654,
		640, 1, 0, 0, 0, 654, 644, 1, 0, 0, 0, 654, 645, 1, 0, 0, 0, 654, 646,
		1, 0, 0, 0, 654, 647, 1, 0, 0, 0, 655, 93, 1, 0, 0, 0, 656, 658, 5, 27,
		0, 0, 657, 659, 3, 100, 50, 0, 658, 657, 1, 0, 0, 0, 658, 659, 1, 0, 0,
		0, 659, 95, 1, 0, 0, 0, 660, 661, 5, 36, 0, 0, 661, 662, 5, 51, 0, 0, 662,
		663, 3, 92, 46, 0, 663, 664, 5, 60, 0, 0, 664, 665, 3, 120, 60, 0, 665,
		666, 5, 52, 0, 0, 666, 97, 1, 0, 0, 0, 667, 668, 7, 8, 0, 0, 668, 669,
		5, 36, 0, 0, 669, 670, 5, 51, 0, 0, 670, 671, 3, 92, 46, 0, 671, 676, 5,
		60, 0, 0, 672, 677, 3, 120, 60, 0, 673, 674, 5, 44, 0, 0, 674, 675, 5,
		61, 0, 0, 675, 677, 3, 70, 35, 0, 676, 672, 1, 0, 0, 0, 676, 673, 1, 0,
		0, 0, 677, 678, 1, 0, 0, 0, 678, 679, 5, 52, 0, 0, 679, 99, 1, 0, 0, 0,
		680, 681, 5, 51, 0, 0, 681, 682, 3, 70, 35, 0, 682, 683, 5, 52, 0, 0, 683,
		101, 1, 0, 0, 0, 684, 685, 7, 9, 0, 0, 685, 103, 1, 0, 0, 0, 686, 689,
		3, 70, 35, 0, 687, 689, 3, 112, 56, 0, 688, 686, 1, 0, 0, 0, 688, 687,
		1, 0, 0, 0, 689, 105, 1, 0, 0, 0, 690, 691, 7, 10, 0, 0, 691, 107, 1, 0,
		0, 0, 692, 695, 3, 86, 43, 0, 693, 695, 5, 89, 0, 0, 694, 692, 1, 0, 0,
		0, 694, 693, 1, 0, 0, 0, 695, 109, 1, 0, 0, 0, 696, 703, 3, 92, 46, 0,
		697, 703, 3, 98, 49, 0, 698, 700, 5, 28, 0, 0, 699, 701, 3, 100, 50, 0,
		700, 699, 1, 0, 0, 0, 700, 701, 1, 0, 0, 0, 701, 703, 1, 0, 0, 0, 702,
		696, 1, 0, 0, 0, 702, 697, 1, 0, 0, 0, 702, 698, 1, 0, 0, 0, 703, 111,
		1, 0, 0, 0, 704, 705, 3, 92, 46, 0, 705, 706, 5, 88, 0, 0, 706, 719, 1,
		0, 0, 0, 707, 708, 3, 94, 47, 0, 708, 709, 5, 88, 0, 0, 709, 719, 1, 0,
		0, 0, 710, 711, 7, 1, 0, 0, 711, 713, 5, 88, 0, 0, 712, 714, 3, 100, 50,
		0, 713, 712, 1, 0, 0, 0, 713, 714, 1, 0, 0, 0, 714, 719, 1, 0, 0, 0, 715,
		716, 3, 98, 49, 0, 716, 717, 5, 88, 0, 0, 717, 719, 1, 0, 0, 0, 718, 704,
		1, 0, 0, 0, 718, 707, 1, 0, 0, 0, 718, 710, 1, 0, 0, 0, 718, 715, 1, 0,
		0, 0, 719, 113, 1, 0, 0, 0, 720, 725, 3, 112, 56, 0, 721, 722, 5, 60, 0,
		0, 722, 724, 3, 112, 56, 0, 723, 721, 1, 0, 0, 0, 724, 727, 1, 0, 0, 0,
		725, 723, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 729, 1, 0, 0, 0, 727,
		725, 1, 0, 0, 0, 728, 730, 5, 60, 0, 0, 729, 728, 1, 0, 0, 0, 729, 730,
		1, 0, 0, 0, 730, 115, 1, 0, 0, 0, 731, 736, 3, 104, 52, 0, 732, 733, 5,
		60, 0, 0, 733, 735, 3, 104, 52, 0, 734, 732, 1, 0, 0, 0, 735, 738, 1, 0,
		0, 0, 736, 734, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 740, 1, 0, 0, 0,
		738, 736, 1, 0, 0, 0, 739, 741, 5, 60, 0, 0, 740, 739, 1, 0, 0, 0, 740,
		741, 1, 0, 0, 0, 741, 117, 1, 0, 0, 0, 742, 747, 3, 106, 53, 0, 743, 744,
		5, 60, 0, 0, 744, 746, 3, 106, 53, 0, 745, 743, 1, 0, 0, 0, 746, 749, 1,
		0, 0, 0, 747, 745, 1, 0, 0, 0, 747, 748, 1, 0, 0, 0, 748, 751, 1, 0, 0,
		0, 749, 747, 1, 0, 0, 0, 750, 752, 5, 60, 0, 0, 751, 750, 1, 0, 0, 0, 751,
		752, 1, 0, 0, 0, 752, 119, 1, 0, 0, 0, 753, 758, 3, 70, 35, 0, 754, 755,
		5, 60, 0, 0, 755, 757, 3, 70, 35, 0, 756, 754, 1, 0, 0, 0, 757, 760, 1,
		0, 0, 0, 758, 756, 1, 0, 0, 0, 758, 759, 1, 0, 0, 0, 759, 762, 1, 0, 0,
		0, 760, 758, 1, 0, 0, 0, 761, 763, 5, 60, 0, 0, 762, 761, 1, 0, 0, 0, 762,
		763, 1, 0, 0, 0, 763, 121, 1, 0, 0, 0, 764, 769, 5, 88, 0, 0, 765, 766,
		5, 60, 0, 0, 766, 768, 5, 88, 0, 0, 767, 765, 1, 0, 0, 0, 768, 771, 1,
		0, 0, 0, 769, 767, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 773, 1, 0, 0,
		0, 771, 769, 1, 0, 0, 0, 772, 774, 5, 60, 0, 0, 773, 772, 1, 0, 0, 0, 773,
		774, 1, 0, 0, 0, 774, 123, 1, 0, 0, 0, 775, 780, 3, 108, 54, 0, 776, 777,
		5, 60, 0, 0, 777, 779, 3, 108, 54, 0, 778, 776, 1, 0, 0, 0, 779, 782, 1,
		0, 0, 0, 780, 778, 1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781, 784, 1, 0, 0,
		0, 782, 780, 1, 0, 0, 0, 783, 785, 5, 60, 0, 0, 784, 783, 1, 0, 0, 0, 784,
		785, 1, 0, 0, 0, 785, 125, 1, 0, 0, 0, 786, 791, 3, 110, 55, 0, 787, 788,
		5, 60, 0, 0, 788, 790, 3, 110, 55, 0, 789, 787, 1, 0, 0, 0, 790, 793, 1,
		0, 0, 0, 791, 789, 1, 0, 0, 0, 791, 792, 1, 0, 0, 0, 792, 795, 1, 0, 0,
		0, 793, 791, 1, 0, 0, 0, 794, 796, 5, 60, 0, 0, 795, 794, 1, 0, 0, 0, 795,
		796, 1, 0, 0, 0, 796, 127, 1, 0, 0, 0, 94, 129, 134, 147, 178, 180, 184,
		190, 200, 229, 240, 245, 257, 263, 270, 277, 283, 286, 289, 297, 303, 306,
		309, 312, 315, 320, 336, 341, 355, 363, 375, 379, 387, 391, 399, 402, 411,
		421, 429, 432, 436, 440, 453, 467, 471, 508, 510, 518, 524, 530, 534, 538,
		546, 550, 557, 562, 566, 570, 578, 583, 587, 591, 593, 601, 618, 620, 626,
		630, 634, 638, 642, 652, 654, 658, 676, 688, 694, 700, 702, 713, 718, 725,
		729, 736, 740, 747, 751, 758, 762, 769, 773, 780, 784, 791, 795,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// qasm3ParserInit initializes any static state used to implement qasm3Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// Newqasm3Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Qasm3ParserInit() {
	staticData := &qasm3parserParserStaticData
	staticData.once.Do(qasm3parserParserInit)
}

// Newqasm3Parser produces a new parser instance for the optional input antlr.TokenStream.
func Newqasm3Parser(input antlr.TokenStream) *qasm3Parser {
	Qasm3ParserInit()
	this := new(qasm3Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &qasm3parserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "qasm3Parser.g4"

	return this
}

// qasm3Parser tokens.
const (
	qasm3ParserEOF                          = antlr.TokenEOF
	qasm3ParserOPENQASM                     = 1
	qasm3ParserINCLUDE                      = 2
	qasm3ParserDEFCALGRAMMAR                = 3
	qasm3ParserDEF                          = 4
	qasm3ParserCAL                          = 5
	qasm3ParserDEFCAL                       = 6
	qasm3ParserGATE                         = 7
	qasm3ParserEXTERN                       = 8
	qasm3ParserBOX                          = 9
	qasm3ParserLET                          = 10
	qasm3ParserBREAK                        = 11
	qasm3ParserCONTINUE                     = 12
	qasm3ParserIF                           = 13
	qasm3ParserELSE                         = 14
	qasm3ParserEND                          = 15
	qasm3ParserRETURN                       = 16
	qasm3ParserFOR                          = 17
	qasm3ParserWHILE                        = 18
	qasm3ParserIN                           = 19
	qasm3ParserPRAGMA                       = 20
	qasm3ParserAnnotationKeyword            = 21
	qasm3ParserINPUT                        = 22
	qasm3ParserOUTPUT                       = 23
	qasm3ParserCONST                        = 24
	qasm3ParserMUTABLE                      = 25
	qasm3ParserQREG                         = 26
	qasm3ParserQUBIT                        = 27
	qasm3ParserCREG                         = 28
	qasm3ParserBOOL                         = 29
	qasm3ParserBIT                          = 30
	qasm3ParserINT                          = 31
	qasm3ParserUINT                         = 32
	qasm3ParserFLOAT                        = 33
	qasm3ParserANGLE                        = 34
	qasm3ParserCOMPLEX                      = 35
	qasm3ParserARRAY                        = 36
	qasm3ParserDURATION                     = 37
	qasm3ParserSTRETCH                      = 38
	qasm3ParserGPHASE                       = 39
	qasm3ParserINV                          = 40
	qasm3ParserPOW                          = 41
	qasm3ParserCTRL                         = 42
	qasm3ParserNEGCTRL                      = 43
	qasm3ParserDIM                          = 44
	qasm3ParserDURATIONOF                   = 45
	qasm3ParserDELAY                        = 46
	qasm3ParserRESET                        = 47
	qasm3ParserMEASURE                      = 48
	qasm3ParserBARRIER                      = 49
	qasm3ParserBooleanLiteral               = 50
	qasm3ParserLBRACKET                     = 51
	qasm3ParserRBRACKET                     = 52
	qasm3ParserLBRACE                       = 53
	qasm3ParserRBRACE                       = 54
	qasm3ParserLPAREN                       = 55
	qasm3ParserRPAREN                       = 56
	qasm3ParserCOLON                        = 57
	qasm3ParserSEMICOLON                    = 58
	qasm3ParserDOT                          = 59
	qasm3ParserCOMMA                        = 60
	qasm3ParserEQUALS                       = 61
	qasm3ParserARROW                        = 62
	qasm3ParserPLUS                         = 63
	qasm3ParserDOUBLE_PLUS                  = 64
	qasm3ParserMINUS                        = 65
	qasm3ParserASTERISK                     = 66
	qasm3ParserDOUBLE_ASTERISK              = 67
	qasm3ParserSLASH                        = 68
	qasm3ParserPERCENT                      = 69
	qasm3ParserPIPE                         = 70
	qasm3ParserDOUBLE_PIPE                  = 71
	qasm3ParserAMPERSAND                    = 72
	qasm3ParserDOUBLE_AMPERSAND             = 73
	qasm3ParserCARET                        = 74
	qasm3ParserAT                           = 75
	qasm3ParserTILDE                        = 76
	qasm3ParserEXCLAMATION_POINT            = 77
	qasm3ParserEqualityOperator             = 78
	qasm3ParserCompoundAssignmentOperator   = 79
	qasm3ParserComparisonOperator           = 80
	qasm3ParserBitshiftOperator             = 81
	qasm3ParserIMAG                         = 82
	qasm3ParserImaginaryLiteral             = 83
	qasm3ParserBinaryIntegerLiteral         = 84
	qasm3ParserOctalIntegerLiteral          = 85
	qasm3ParserDecimalIntegerLiteral        = 86
	qasm3ParserHexIntegerLiteral            = 87
	qasm3ParserIdentifier                   = 88
	qasm3ParserHardwareQubit                = 89
	qasm3ParserFloatLiteral                 = 90
	qasm3ParserTimingLiteral                = 91
	qasm3ParserBitstringLiteral             = 92
	qasm3ParserStringLiteral                = 93
	qasm3ParserWhitespace                   = 94
	qasm3ParserNewline                      = 95
	qasm3ParserLineComment                  = 96
	qasm3ParserBlockComment                 = 97
	qasm3ParserVERSION_IDENTIFER_WHITESPACE = 98
	qasm3ParserVersionSpecifier             = 99
	qasm3ParserEAT_INITIAL_SPACE            = 100
	qasm3ParserEAT_LINE_END                 = 101
	qasm3ParserRemainingLineContent         = 102
	qasm3ParserCAL_PRELUDE_WHITESPACE       = 103
	qasm3ParserCAL_PRELUDE_COMMENT          = 104
	qasm3ParserDEFCAL_PRELUDE_WHITESPACE    = 105
	qasm3ParserDEFCAL_PRELUDE_COMMENT       = 106
	qasm3ParserCalibrationBlock             = 107
)

// qasm3Parser rules.
const (
	qasm3ParserRULE_program                         = 0
	qasm3ParserRULE_version                         = 1
	qasm3ParserRULE_statement                       = 2
	qasm3ParserRULE_annotation                      = 3
	qasm3ParserRULE_scope                           = 4
	qasm3ParserRULE_pragma                          = 5
	qasm3ParserRULE_statementOrScope                = 6
	qasm3ParserRULE_calibrationGrammarStatement     = 7
	qasm3ParserRULE_includeStatement                = 8
	qasm3ParserRULE_breakStatement                  = 9
	qasm3ParserRULE_continueStatement               = 10
	qasm3ParserRULE_endStatement                    = 11
	qasm3ParserRULE_forStatement                    = 12
	qasm3ParserRULE_ifStatement                     = 13
	qasm3ParserRULE_returnStatement                 = 14
	qasm3ParserRULE_whileStatement                  = 15
	qasm3ParserRULE_barrierStatement                = 16
	qasm3ParserRULE_boxStatement                    = 17
	qasm3ParserRULE_delayStatement                  = 18
	qasm3ParserRULE_gateCallStatement               = 19
	qasm3ParserRULE_measureArrowAssignmentStatement = 20
	qasm3ParserRULE_resetStatement                  = 21
	qasm3ParserRULE_aliasDeclarationStatement       = 22
	qasm3ParserRULE_classicalDeclarationStatement   = 23
	qasm3ParserRULE_constDeclarationStatement       = 24
	qasm3ParserRULE_ioDeclarationStatement          = 25
	qasm3ParserRULE_oldStyleDeclarationStatement    = 26
	qasm3ParserRULE_quantumDeclarationStatement     = 27
	qasm3ParserRULE_defStatement                    = 28
	qasm3ParserRULE_externStatement                 = 29
	qasm3ParserRULE_gateStatement                   = 30
	qasm3ParserRULE_assignmentStatement             = 31
	qasm3ParserRULE_expressionStatement             = 32
	qasm3ParserRULE_calStatement                    = 33
	qasm3ParserRULE_defcalStatement                 = 34
	qasm3ParserRULE_expression                      = 35
	qasm3ParserRULE_aliasExpression                 = 36
	qasm3ParserRULE_declarationExpression           = 37
	qasm3ParserRULE_measureExpression               = 38
	qasm3ParserRULE_rangeExpression                 = 39
	qasm3ParserRULE_setExpression                   = 40
	qasm3ParserRULE_arrayLiteral                    = 41
	qasm3ParserRULE_indexOperator                   = 42
	qasm3ParserRULE_indexedIdentifier               = 43
	qasm3ParserRULE_returnSignature                 = 44
	qasm3ParserRULE_gateModifier                    = 45
	qasm3ParserRULE_scalarType                      = 46
	qasm3ParserRULE_qubitType                       = 47
	qasm3ParserRULE_arrayType                       = 48
	qasm3ParserRULE_arrayReferenceType              = 49
	qasm3ParserRULE_designator                      = 50
	qasm3ParserRULE_defcalTarget                    = 51
	qasm3ParserRULE_defcalArgumentDefinition        = 52
	qasm3ParserRULE_defcalOperand                   = 53
	qasm3ParserRULE_gateOperand                     = 54
	qasm3ParserRULE_externArgument                  = 55
	qasm3ParserRULE_argumentDefinition              = 56
	qasm3ParserRULE_argumentDefinitionList          = 57
	qasm3ParserRULE_defcalArgumentDefinitionList    = 58
	qasm3ParserRULE_defcalOperandList               = 59
	qasm3ParserRULE_expressionList                  = 60
	qasm3ParserRULE_identifierList                  = 61
	qasm3ParserRULE_gateOperandList                 = 62
	qasm3ParserRULE_externArgumentList              = 63
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_program
	return p
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEOF, 0)
}

func (s *ProgramContext) Version() IVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionContext)
}

func (s *ProgramContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Program() (localctx IProgramContext) {
	this := p
	_ = this

	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, qasm3ParserRULE_program)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(129)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserOPENQASM {
		{
			p.SetState(128)
			p.Version()
		}

	}
	p.SetState(134)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<qasm3ParserINCLUDE)|(1<<qasm3ParserDEFCALGRAMMAR)|(1<<qasm3ParserDEF)|(1<<qasm3ParserCAL)|(1<<qasm3ParserDEFCAL)|(1<<qasm3ParserGATE)|(1<<qasm3ParserEXTERN)|(1<<qasm3ParserBOX)|(1<<qasm3ParserLET)|(1<<qasm3ParserBREAK)|(1<<qasm3ParserCONTINUE)|(1<<qasm3ParserIF)|(1<<qasm3ParserEND)|(1<<qasm3ParserRETURN)|(1<<qasm3ParserFOR)|(1<<qasm3ParserWHILE)|(1<<qasm3ParserPRAGMA)|(1<<qasm3ParserAnnotationKeyword)|(1<<qasm3ParserINPUT)|(1<<qasm3ParserOUTPUT)|(1<<qasm3ParserCONST)|(1<<qasm3ParserQREG)|(1<<qasm3ParserQUBIT)|(1<<qasm3ParserCREG)|(1<<qasm3ParserBOOL)|(1<<qasm3ParserBIT)|(1<<qasm3ParserINT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(qasm3ParserUINT-32))|(1<<(qasm3ParserFLOAT-32))|(1<<(qasm3ParserANGLE-32))|(1<<(qasm3ParserCOMPLEX-32))|(1<<(qasm3ParserARRAY-32))|(1<<(qasm3ParserDURATION-32))|(1<<(qasm3ParserSTRETCH-32))|(1<<(qasm3ParserGPHASE-32))|(1<<(qasm3ParserINV-32))|(1<<(qasm3ParserPOW-32))|(1<<(qasm3ParserCTRL-32))|(1<<(qasm3ParserNEGCTRL-32))|(1<<(qasm3ParserDURATIONOF-32))|(1<<(qasm3ParserDELAY-32))|(1<<(qasm3ParserRESET-32))|(1<<(qasm3ParserMEASURE-32))|(1<<(qasm3ParserBARRIER-32))|(1<<(qasm3ParserBooleanLiteral-32))|(1<<(qasm3ParserLPAREN-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(qasm3ParserMINUS-65))|(1<<(qasm3ParserTILDE-65))|(1<<(qasm3ParserEXCLAMATION_POINT-65))|(1<<(qasm3ParserImaginaryLiteral-65))|(1<<(qasm3ParserBinaryIntegerLiteral-65))|(1<<(qasm3ParserOctalIntegerLiteral-65))|(1<<(qasm3ParserDecimalIntegerLiteral-65))|(1<<(qasm3ParserHexIntegerLiteral-65))|(1<<(qasm3ParserIdentifier-65))|(1<<(qasm3ParserHardwareQubit-65))|(1<<(qasm3ParserFloatLiteral-65))|(1<<(qasm3ParserTimingLiteral-65))|(1<<(qasm3ParserBitstringLiteral-65)))) != 0) {
		{
			p.SetState(131)
			p.Statement()
		}

		p.SetState(136)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(137)
		p.Match(qasm3ParserEOF)
	}

	return localctx
}

// IVersionContext is an interface to support dynamic dispatch.
type IVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVersionContext differentiates from other interfaces.
	IsVersionContext()
}

type VersionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionContext() *VersionContext {
	var p = new(VersionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_version
	return p
}

func (*VersionContext) IsVersionContext() {}

func NewVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionContext {
	var p = new(VersionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_version

	return p
}

func (s *VersionContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionContext) OPENQASM() antlr.TerminalNode {
	return s.GetToken(qasm3ParserOPENQASM, 0)
}

func (s *VersionContext) VersionSpecifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserVersionSpecifier, 0)
}

func (s *VersionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *VersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterVersion(s)
	}
}

func (s *VersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitVersion(s)
	}
}

func (s *VersionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitVersion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Version() (localctx IVersionContext) {
	this := p
	_ = this

	localctx = NewVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, qasm3ParserRULE_version)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(139)
		p.Match(qasm3ParserOPENQASM)
	}
	{
		p.SetState(140)
		p.Match(qasm3ParserVersionSpecifier)
	}
	{
		p.SetState(141)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Pragma() IPragmaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaContext)
}

func (s *StatementContext) AliasDeclarationStatement() IAliasDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasDeclarationStatementContext)
}

func (s *StatementContext) AssignmentStatement() IAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentStatementContext)
}

func (s *StatementContext) BarrierStatement() IBarrierStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBarrierStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBarrierStatementContext)
}

func (s *StatementContext) BoxStatement() IBoxStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoxStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoxStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) CalStatement() ICalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICalStatementContext)
}

func (s *StatementContext) CalibrationGrammarStatement() ICalibrationGrammarStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICalibrationGrammarStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICalibrationGrammarStatementContext)
}

func (s *StatementContext) ClassicalDeclarationStatement() IClassicalDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassicalDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassicalDeclarationStatementContext)
}

func (s *StatementContext) ConstDeclarationStatement() IConstDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstDeclarationStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) DefStatement() IDefStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefStatementContext)
}

func (s *StatementContext) DefcalStatement() IDefcalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalStatementContext)
}

func (s *StatementContext) DelayStatement() IDelayStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelayStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelayStatementContext)
}

func (s *StatementContext) EndStatement() IEndStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) ExternStatement() IExternStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) GateCallStatement() IGateCallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateCallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateCallStatementContext)
}

func (s *StatementContext) GateStatement() IGateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) IncludeStatement() IIncludeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncludeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncludeStatementContext)
}

func (s *StatementContext) IoDeclarationStatement() IIoDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIoDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIoDeclarationStatementContext)
}

func (s *StatementContext) MeasureArrowAssignmentStatement() IMeasureArrowAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureArrowAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureArrowAssignmentStatementContext)
}

func (s *StatementContext) OldStyleDeclarationStatement() IOldStyleDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOldStyleDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOldStyleDeclarationStatementContext)
}

func (s *StatementContext) QuantumDeclarationStatement() IQuantumDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantumDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantumDeclarationStatementContext)
}

func (s *StatementContext) ResetStatement() IResetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, qasm3ParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(180)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserPRAGMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(143)
			p.Pragma()
		}

	case qasm3ParserINCLUDE, qasm3ParserDEFCALGRAMMAR, qasm3ParserDEF, qasm3ParserCAL, qasm3ParserDEFCAL, qasm3ParserGATE, qasm3ParserEXTERN, qasm3ParserBOX, qasm3ParserLET, qasm3ParserBREAK, qasm3ParserCONTINUE, qasm3ParserIF, qasm3ParserEND, qasm3ParserRETURN, qasm3ParserFOR, qasm3ParserWHILE, qasm3ParserAnnotationKeyword, qasm3ParserINPUT, qasm3ParserOUTPUT, qasm3ParserCONST, qasm3ParserQREG, qasm3ParserQUBIT, qasm3ParserCREG, qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserGPHASE, qasm3ParserINV, qasm3ParserPOW, qasm3ParserCTRL, qasm3ParserNEGCTRL, qasm3ParserDURATIONOF, qasm3ParserDELAY, qasm3ParserRESET, qasm3ParserMEASURE, qasm3ParserBARRIER, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(147)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == qasm3ParserAnnotationKeyword {
			{
				p.SetState(144)
				p.Annotation()
			}

			p.SetState(149)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(178)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(150)
				p.AliasDeclarationStatement()
			}

		case 2:
			{
				p.SetState(151)
				p.AssignmentStatement()
			}

		case 3:
			{
				p.SetState(152)
				p.BarrierStatement()
			}

		case 4:
			{
				p.SetState(153)
				p.BoxStatement()
			}

		case 5:
			{
				p.SetState(154)
				p.BreakStatement()
			}

		case 6:
			{
				p.SetState(155)
				p.CalStatement()
			}

		case 7:
			{
				p.SetState(156)
				p.CalibrationGrammarStatement()
			}

		case 8:
			{
				p.SetState(157)
				p.ClassicalDeclarationStatement()
			}

		case 9:
			{
				p.SetState(158)
				p.ConstDeclarationStatement()
			}

		case 10:
			{
				p.SetState(159)
				p.ContinueStatement()
			}

		case 11:
			{
				p.SetState(160)
				p.DefStatement()
			}

		case 12:
			{
				p.SetState(161)
				p.DefcalStatement()
			}

		case 13:
			{
				p.SetState(162)
				p.DelayStatement()
			}

		case 14:
			{
				p.SetState(163)
				p.EndStatement()
			}

		case 15:
			{
				p.SetState(164)
				p.ExpressionStatement()
			}

		case 16:
			{
				p.SetState(165)
				p.ExternStatement()
			}

		case 17:
			{
				p.SetState(166)
				p.ForStatement()
			}

		case 18:
			{
				p.SetState(167)
				p.GateCallStatement()
			}

		case 19:
			{
				p.SetState(168)
				p.GateStatement()
			}

		case 20:
			{
				p.SetState(169)
				p.IfStatement()
			}

		case 21:
			{
				p.SetState(170)
				p.IncludeStatement()
			}

		case 22:
			{
				p.SetState(171)
				p.IoDeclarationStatement()
			}

		case 23:
			{
				p.SetState(172)
				p.MeasureArrowAssignmentStatement()
			}

		case 24:
			{
				p.SetState(173)
				p.OldStyleDeclarationStatement()
			}

		case 25:
			{
				p.SetState(174)
				p.QuantumDeclarationStatement()
			}

		case 26:
			{
				p.SetState(175)
				p.ResetStatement()
			}

		case 27:
			{
				p.SetState(176)
				p.ReturnStatement()
			}

		case 28:
			{
				p.SetState(177)
				p.WhileStatement()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AnnotationKeyword() antlr.TerminalNode {
	return s.GetToken(qasm3ParserAnnotationKeyword, 0)
}

func (s *AnnotationContext) RemainingLineContent() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRemainingLineContent, 0)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Annotation() (localctx IAnnotationContext) {
	this := p
	_ = this

	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, qasm3ParserRULE_annotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(182)
		p.Match(qasm3ParserAnnotationKeyword)
	}
	p.SetState(184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserRemainingLineContent {
		{
			p.SetState(183)
			p.Match(qasm3ParserRemainingLineContent)
		}

	}

	return localctx
}

// IScopeContext is an interface to support dynamic dispatch.
type IScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScopeContext differentiates from other interfaces.
	IsScopeContext()
}

type ScopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScopeContext() *ScopeContext {
	var p = new(ScopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_scope
	return p
}

func (*ScopeContext) IsScopeContext() {}

func NewScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScopeContext {
	var p = new(ScopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_scope

	return p
}

func (s *ScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *ScopeContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *ScopeContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *ScopeContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *ScopeContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterScope(s)
	}
}

func (s *ScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitScope(s)
	}
}

func (s *ScopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitScope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Scope() (localctx IScopeContext) {
	this := p
	_ = this

	localctx = NewScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, qasm3ParserRULE_scope)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(186)
		p.Match(qasm3ParserLBRACE)
	}
	p.SetState(190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<qasm3ParserINCLUDE)|(1<<qasm3ParserDEFCALGRAMMAR)|(1<<qasm3ParserDEF)|(1<<qasm3ParserCAL)|(1<<qasm3ParserDEFCAL)|(1<<qasm3ParserGATE)|(1<<qasm3ParserEXTERN)|(1<<qasm3ParserBOX)|(1<<qasm3ParserLET)|(1<<qasm3ParserBREAK)|(1<<qasm3ParserCONTINUE)|(1<<qasm3ParserIF)|(1<<qasm3ParserEND)|(1<<qasm3ParserRETURN)|(1<<qasm3ParserFOR)|(1<<qasm3ParserWHILE)|(1<<qasm3ParserPRAGMA)|(1<<qasm3ParserAnnotationKeyword)|(1<<qasm3ParserINPUT)|(1<<qasm3ParserOUTPUT)|(1<<qasm3ParserCONST)|(1<<qasm3ParserQREG)|(1<<qasm3ParserQUBIT)|(1<<qasm3ParserCREG)|(1<<qasm3ParserBOOL)|(1<<qasm3ParserBIT)|(1<<qasm3ParserINT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(qasm3ParserUINT-32))|(1<<(qasm3ParserFLOAT-32))|(1<<(qasm3ParserANGLE-32))|(1<<(qasm3ParserCOMPLEX-32))|(1<<(qasm3ParserARRAY-32))|(1<<(qasm3ParserDURATION-32))|(1<<(qasm3ParserSTRETCH-32))|(1<<(qasm3ParserGPHASE-32))|(1<<(qasm3ParserINV-32))|(1<<(qasm3ParserPOW-32))|(1<<(qasm3ParserCTRL-32))|(1<<(qasm3ParserNEGCTRL-32))|(1<<(qasm3ParserDURATIONOF-32))|(1<<(qasm3ParserDELAY-32))|(1<<(qasm3ParserRESET-32))|(1<<(qasm3ParserMEASURE-32))|(1<<(qasm3ParserBARRIER-32))|(1<<(qasm3ParserBooleanLiteral-32))|(1<<(qasm3ParserLPAREN-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(qasm3ParserMINUS-65))|(1<<(qasm3ParserTILDE-65))|(1<<(qasm3ParserEXCLAMATION_POINT-65))|(1<<(qasm3ParserImaginaryLiteral-65))|(1<<(qasm3ParserBinaryIntegerLiteral-65))|(1<<(qasm3ParserOctalIntegerLiteral-65))|(1<<(qasm3ParserDecimalIntegerLiteral-65))|(1<<(qasm3ParserHexIntegerLiteral-65))|(1<<(qasm3ParserIdentifier-65))|(1<<(qasm3ParserHardwareQubit-65))|(1<<(qasm3ParserFloatLiteral-65))|(1<<(qasm3ParserTimingLiteral-65))|(1<<(qasm3ParserBitstringLiteral-65)))) != 0) {
		{
			p.SetState(187)
			p.Statement()
		}

		p.SetState(192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(193)
		p.Match(qasm3ParserRBRACE)
	}

	return localctx
}

// IPragmaContext is an interface to support dynamic dispatch.
type IPragmaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPragmaContext differentiates from other interfaces.
	IsPragmaContext()
}

type PragmaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaContext() *PragmaContext {
	var p = new(PragmaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_pragma
	return p
}

func (*PragmaContext) IsPragmaContext() {}

func NewPragmaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaContext {
	var p = new(PragmaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_pragma

	return p
}

func (s *PragmaContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPRAGMA, 0)
}

func (s *PragmaContext) RemainingLineContent() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRemainingLineContent, 0)
}

func (s *PragmaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PragmaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterPragma(s)
	}
}

func (s *PragmaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitPragma(s)
	}
}

func (s *PragmaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitPragma(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Pragma() (localctx IPragmaContext) {
	this := p
	_ = this

	localctx = NewPragmaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, qasm3ParserRULE_pragma)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(195)
		p.Match(qasm3ParserPRAGMA)
	}
	{
		p.SetState(196)
		p.Match(qasm3ParserRemainingLineContent)
	}

	return localctx
}

// IStatementOrScopeContext is an interface to support dynamic dispatch.
type IStatementOrScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementOrScopeContext differentiates from other interfaces.
	IsStatementOrScopeContext()
}

type StatementOrScopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementOrScopeContext() *StatementOrScopeContext {
	var p = new(StatementOrScopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_statementOrScope
	return p
}

func (*StatementOrScopeContext) IsStatementOrScopeContext() {}

func NewStatementOrScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementOrScopeContext {
	var p = new(StatementOrScopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_statementOrScope

	return p
}

func (s *StatementOrScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementOrScopeContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementOrScopeContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *StatementOrScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementOrScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementOrScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterStatementOrScope(s)
	}
}

func (s *StatementOrScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitStatementOrScope(s)
	}
}

func (s *StatementOrScopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitStatementOrScope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) StatementOrScope() (localctx IStatementOrScopeContext) {
	this := p
	_ = this

	localctx = NewStatementOrScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, qasm3ParserRULE_statementOrScope)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(200)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserINCLUDE, qasm3ParserDEFCALGRAMMAR, qasm3ParserDEF, qasm3ParserCAL, qasm3ParserDEFCAL, qasm3ParserGATE, qasm3ParserEXTERN, qasm3ParserBOX, qasm3ParserLET, qasm3ParserBREAK, qasm3ParserCONTINUE, qasm3ParserIF, qasm3ParserEND, qasm3ParserRETURN, qasm3ParserFOR, qasm3ParserWHILE, qasm3ParserPRAGMA, qasm3ParserAnnotationKeyword, qasm3ParserINPUT, qasm3ParserOUTPUT, qasm3ParserCONST, qasm3ParserQREG, qasm3ParserQUBIT, qasm3ParserCREG, qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserGPHASE, qasm3ParserINV, qasm3ParserPOW, qasm3ParserCTRL, qasm3ParserNEGCTRL, qasm3ParserDURATIONOF, qasm3ParserDELAY, qasm3ParserRESET, qasm3ParserMEASURE, qasm3ParserBARRIER, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(198)
			p.Statement()
		}

	case qasm3ParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(199)
			p.Scope()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICalibrationGrammarStatementContext is an interface to support dynamic dispatch.
type ICalibrationGrammarStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCalibrationGrammarStatementContext differentiates from other interfaces.
	IsCalibrationGrammarStatementContext()
}

type CalibrationGrammarStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalibrationGrammarStatementContext() *CalibrationGrammarStatementContext {
	var p = new(CalibrationGrammarStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_calibrationGrammarStatement
	return p
}

func (*CalibrationGrammarStatementContext) IsCalibrationGrammarStatementContext() {}

func NewCalibrationGrammarStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalibrationGrammarStatementContext {
	var p = new(CalibrationGrammarStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_calibrationGrammarStatement

	return p
}

func (s *CalibrationGrammarStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CalibrationGrammarStatementContext) DEFCALGRAMMAR() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDEFCALGRAMMAR, 0)
}

func (s *CalibrationGrammarStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserStringLiteral, 0)
}

func (s *CalibrationGrammarStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *CalibrationGrammarStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalibrationGrammarStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalibrationGrammarStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterCalibrationGrammarStatement(s)
	}
}

func (s *CalibrationGrammarStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitCalibrationGrammarStatement(s)
	}
}

func (s *CalibrationGrammarStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitCalibrationGrammarStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) CalibrationGrammarStatement() (localctx ICalibrationGrammarStatementContext) {
	this := p
	_ = this

	localctx = NewCalibrationGrammarStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, qasm3ParserRULE_calibrationGrammarStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(202)
		p.Match(qasm3ParserDEFCALGRAMMAR)
	}
	{
		p.SetState(203)
		p.Match(qasm3ParserStringLiteral)
	}
	{
		p.SetState(204)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IIncludeStatementContext is an interface to support dynamic dispatch.
type IIncludeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIncludeStatementContext differentiates from other interfaces.
	IsIncludeStatementContext()
}

type IncludeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludeStatementContext() *IncludeStatementContext {
	var p = new(IncludeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_includeStatement
	return p
}

func (*IncludeStatementContext) IsIncludeStatementContext() {}

func NewIncludeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludeStatementContext {
	var p = new(IncludeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_includeStatement

	return p
}

func (s *IncludeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludeStatementContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserINCLUDE, 0)
}

func (s *IncludeStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserStringLiteral, 0)
}

func (s *IncludeStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *IncludeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncludeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIncludeStatement(s)
	}
}

func (s *IncludeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIncludeStatement(s)
	}
}

func (s *IncludeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIncludeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IncludeStatement() (localctx IIncludeStatementContext) {
	this := p
	_ = this

	localctx = NewIncludeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, qasm3ParserRULE_includeStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		p.Match(qasm3ParserINCLUDE)
	}
	{
		p.SetState(207)
		p.Match(qasm3ParserStringLiteral)
	}
	{
		p.SetState(208)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBREAK, 0)
}

func (s *BreakStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, qasm3ParserRULE_breakStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(210)
		p.Match(qasm3ParserBREAK)
	}
	{
		p.SetState(211)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCONTINUE, 0)
}

func (s *ContinueStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, qasm3ParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(213)
		p.Match(qasm3ParserCONTINUE)
	}
	{
		p.SetState(214)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IEndStatementContext is an interface to support dynamic dispatch.
type IEndStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndStatementContext differentiates from other interfaces.
	IsEndStatementContext()
}

type EndStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndStatementContext() *EndStatementContext {
	var p = new(EndStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_endStatement
	return p
}

func (*EndStatementContext) IsEndStatementContext() {}

func NewEndStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndStatementContext {
	var p = new(EndStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_endStatement

	return p
}

func (s *EndStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EndStatementContext) END() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEND, 0)
}

func (s *EndStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *EndStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterEndStatement(s)
	}
}

func (s *EndStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitEndStatement(s)
	}
}

func (s *EndStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitEndStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) EndStatement() (localctx IEndStatementContext) {
	this := p
	_ = this

	localctx = NewEndStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, qasm3ParserRULE_endStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(216)
		p.Match(qasm3ParserEND)
	}
	{
		p.SetState(217)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBody returns the body rule contexts.
	GetBody() IStatementOrScopeContext

	// SetBody sets the body rule contexts.
	SetBody(IStatementOrScopeContext)

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	body   IStatementOrScopeContext
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) GetBody() IStatementOrScopeContext { return s.body }

func (s *ForStatementContext) SetBody(v IStatementOrScopeContext) { s.body = v }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(qasm3ParserFOR, 0)
}

func (s *ForStatementContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ForStatementContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserIdentifier)
}

func (s *ForStatementContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, i)
}

func (s *ForStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIN, 0)
}

func (s *ForStatementContext) StatementOrScope() IStatementOrScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementOrScopeContext)
}

func (s *ForStatementContext) SetExpression() ISetExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExpressionContext)
}

func (s *ForStatementContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *ForStatementContext) RangeExpression() IRangeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *ForStatementContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ForStatement() (localctx IForStatementContext) {
	this := p
	_ = this

	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, qasm3ParserRULE_forStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(219)
		p.Match(qasm3ParserFOR)
	}
	{
		p.SetState(220)
		p.ScalarType()
	}
	{
		p.SetState(221)
		p.Match(qasm3ParserIdentifier)
	}
	{
		p.SetState(222)
		p.Match(qasm3ParserIN)
	}
	p.SetState(229)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserLBRACE:
		{
			p.SetState(223)
			p.SetExpression()
		}

	case qasm3ParserLBRACKET:
		{
			p.SetState(224)
			p.Match(qasm3ParserLBRACKET)
		}
		{
			p.SetState(225)
			p.RangeExpression()
		}
		{
			p.SetState(226)
			p.Match(qasm3ParserRBRACKET)
		}

	case qasm3ParserIdentifier:
		{
			p.SetState(228)
			p.Match(qasm3ParserIdentifier)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(231)

		var _x = p.StatementOrScope()

		localctx.(*ForStatementContext).body = _x
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIf_body returns the if_body rule contexts.
	GetIf_body() IStatementOrScopeContext

	// GetElse_body returns the else_body rule contexts.
	GetElse_body() IStatementOrScopeContext

	// SetIf_body sets the if_body rule contexts.
	SetIf_body(IStatementOrScopeContext)

	// SetElse_body sets the else_body rule contexts.
	SetElse_body(IStatementOrScopeContext)

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	if_body   IStatementOrScopeContext
	else_body IStatementOrScopeContext
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) GetIf_body() IStatementOrScopeContext { return s.if_body }

func (s *IfStatementContext) GetElse_body() IStatementOrScopeContext { return s.else_body }

func (s *IfStatementContext) SetIf_body(v IStatementOrScopeContext) { s.if_body = v }

func (s *IfStatementContext) SetElse_body(v IStatementOrScopeContext) { s.else_body = v }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIF, 0)
}

func (s *IfStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *IfStatementContext) AllStatementOrScope() []IStatementOrScopeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			len++
		}
	}

	tst := make([]IStatementOrScopeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementOrScopeContext); ok {
			tst[i] = t.(IStatementOrScopeContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) StatementOrScope(i int) IStatementOrScopeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementOrScopeContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserELSE, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, qasm3ParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(233)
		p.Match(qasm3ParserIF)
	}
	{
		p.SetState(234)
		p.Match(qasm3ParserLPAREN)
	}
	{
		p.SetState(235)
		p.expression(0)
	}
	{
		p.SetState(236)
		p.Match(qasm3ParserRPAREN)
	}
	{
		p.SetState(237)

		var _x = p.StatementOrScope()

		localctx.(*IfStatementContext).if_body = _x
	}
	p.SetState(240)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(238)
			p.Match(qasm3ParserELSE)
		}
		{
			p.SetState(239)

			var _x = p.StatementOrScope()

			localctx.(*IfStatementContext).else_body = _x
		}

	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRETURN, 0)
}

func (s *ReturnStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) MeasureExpression() IMeasureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, qasm3ParserRULE_returnStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.Match(qasm3ParserRETURN)
	}
	p.SetState(245)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		{
			p.SetState(243)
			p.expression(0)
		}

	case qasm3ParserMEASURE:
		{
			p.SetState(244)
			p.MeasureExpression()
		}

	case qasm3ParserSEMICOLON:

	default:
	}
	{
		p.SetState(247)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBody returns the body rule contexts.
	GetBody() IStatementOrScopeContext

	// SetBody sets the body rule contexts.
	SetBody(IStatementOrScopeContext)

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	body   IStatementOrScopeContext
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) GetBody() IStatementOrScopeContext { return s.body }

func (s *WhileStatementContext) SetBody(v IStatementOrScopeContext) { s.body = v }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserWHILE, 0)
}

func (s *WhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *WhileStatementContext) StatementOrScope() IStatementOrScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementOrScopeContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, qasm3ParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(249)
		p.Match(qasm3ParserWHILE)
	}
	{
		p.SetState(250)
		p.Match(qasm3ParserLPAREN)
	}
	{
		p.SetState(251)
		p.expression(0)
	}
	{
		p.SetState(252)
		p.Match(qasm3ParserRPAREN)
	}
	{
		p.SetState(253)

		var _x = p.StatementOrScope()

		localctx.(*WhileStatementContext).body = _x
	}

	return localctx
}

// IBarrierStatementContext is an interface to support dynamic dispatch.
type IBarrierStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBarrierStatementContext differentiates from other interfaces.
	IsBarrierStatementContext()
}

type BarrierStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBarrierStatementContext() *BarrierStatementContext {
	var p = new(BarrierStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_barrierStatement
	return p
}

func (*BarrierStatementContext) IsBarrierStatementContext() {}

func NewBarrierStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BarrierStatementContext {
	var p = new(BarrierStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_barrierStatement

	return p
}

func (s *BarrierStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BarrierStatementContext) BARRIER() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBARRIER, 0)
}

func (s *BarrierStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *BarrierStatementContext) GateOperandList() IGateOperandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandListContext)
}

func (s *BarrierStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BarrierStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BarrierStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBarrierStatement(s)
	}
}

func (s *BarrierStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBarrierStatement(s)
	}
}

func (s *BarrierStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBarrierStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) BarrierStatement() (localctx IBarrierStatementContext) {
	this := p
	_ = this

	localctx = NewBarrierStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, qasm3ParserRULE_barrierStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(255)
		p.Match(qasm3ParserBARRIER)
	}
	p.SetState(257)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserIdentifier || _la == qasm3ParserHardwareQubit {
		{
			p.SetState(256)
			p.GateOperandList()
		}

	}
	{
		p.SetState(259)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IBoxStatementContext is an interface to support dynamic dispatch.
type IBoxStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoxStatementContext differentiates from other interfaces.
	IsBoxStatementContext()
}

type BoxStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoxStatementContext() *BoxStatementContext {
	var p = new(BoxStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_boxStatement
	return p
}

func (*BoxStatementContext) IsBoxStatementContext() {}

func NewBoxStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoxStatementContext {
	var p = new(BoxStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_boxStatement

	return p
}

func (s *BoxStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BoxStatementContext) BOX() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBOX, 0)
}

func (s *BoxStatementContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *BoxStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *BoxStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoxStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoxStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBoxStatement(s)
	}
}

func (s *BoxStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBoxStatement(s)
	}
}

func (s *BoxStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBoxStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) BoxStatement() (localctx IBoxStatementContext) {
	this := p
	_ = this

	localctx = NewBoxStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, qasm3ParserRULE_boxStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(qasm3ParserBOX)
	}
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLBRACKET {
		{
			p.SetState(262)
			p.Designator()
		}

	}
	{
		p.SetState(265)
		p.Scope()
	}

	return localctx
}

// IDelayStatementContext is an interface to support dynamic dispatch.
type IDelayStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelayStatementContext differentiates from other interfaces.
	IsDelayStatementContext()
}

type DelayStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelayStatementContext() *DelayStatementContext {
	var p = new(DelayStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_delayStatement
	return p
}

func (*DelayStatementContext) IsDelayStatementContext() {}

func NewDelayStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelayStatementContext {
	var p = new(DelayStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_delayStatement

	return p
}

func (s *DelayStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelayStatementContext) DELAY() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDELAY, 0)
}

func (s *DelayStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *DelayStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *DelayStatementContext) GateOperandList() IGateOperandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandListContext)
}

func (s *DelayStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelayStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelayStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDelayStatement(s)
	}
}

func (s *DelayStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDelayStatement(s)
	}
}

func (s *DelayStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDelayStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DelayStatement() (localctx IDelayStatementContext) {
	this := p
	_ = this

	localctx = NewDelayStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, qasm3ParserRULE_delayStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(267)
		p.Match(qasm3ParserDELAY)
	}
	{
		p.SetState(268)
		p.Designator()
	}
	p.SetState(270)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserIdentifier || _la == qasm3ParserHardwareQubit {
		{
			p.SetState(269)
			p.GateOperandList()
		}

	}
	{
		p.SetState(272)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IGateCallStatementContext is an interface to support dynamic dispatch.
type IGateCallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGateCallStatementContext differentiates from other interfaces.
	IsGateCallStatementContext()
}

type GateCallStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGateCallStatementContext() *GateCallStatementContext {
	var p = new(GateCallStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateCallStatement
	return p
}

func (*GateCallStatementContext) IsGateCallStatementContext() {}

func NewGateCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateCallStatementContext {
	var p = new(GateCallStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateCallStatement

	return p
}

func (s *GateCallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GateCallStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *GateCallStatementContext) GateOperandList() IGateOperandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandListContext)
}

func (s *GateCallStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *GateCallStatementContext) AllGateModifier() []IGateModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGateModifierContext); ok {
			len++
		}
	}

	tst := make([]IGateModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGateModifierContext); ok {
			tst[i] = t.(IGateModifierContext)
			i++
		}
	}

	return tst
}

func (s *GateCallStatementContext) GateModifier(i int) IGateModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateModifierContext)
}

func (s *GateCallStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *GateCallStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *GateCallStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *GateCallStatementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *GateCallStatementContext) GPHASE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserGPHASE, 0)
}

func (s *GateCallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateCallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateCallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateCallStatement(s)
	}
}

func (s *GateCallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateCallStatement(s)
	}
}

func (s *GateCallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateCallStatement() (localctx IGateCallStatementContext) {
	this := p
	_ = this

	localctx = NewGateCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, qasm3ParserRULE_gateCallStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(315)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(qasm3ParserINV-40))|(1<<(qasm3ParserPOW-40))|(1<<(qasm3ParserCTRL-40))|(1<<(qasm3ParserNEGCTRL-40)))) != 0 {
			{
				p.SetState(274)
				p.GateModifier()
			}

			p.SetState(279)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(280)
			p.Match(qasm3ParserIdentifier)
		}
		p.SetState(286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLPAREN {
			{
				p.SetState(281)
				p.Match(qasm3ParserLPAREN)
			}
			p.SetState(283)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(qasm3ParserBOOL-29))|(1<<(qasm3ParserBIT-29))|(1<<(qasm3ParserINT-29))|(1<<(qasm3ParserUINT-29))|(1<<(qasm3ParserFLOAT-29))|(1<<(qasm3ParserANGLE-29))|(1<<(qasm3ParserCOMPLEX-29))|(1<<(qasm3ParserARRAY-29))|(1<<(qasm3ParserDURATION-29))|(1<<(qasm3ParserSTRETCH-29))|(1<<(qasm3ParserDURATIONOF-29))|(1<<(qasm3ParserBooleanLiteral-29))|(1<<(qasm3ParserLPAREN-29)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(qasm3ParserMINUS-65))|(1<<(qasm3ParserTILDE-65))|(1<<(qasm3ParserEXCLAMATION_POINT-65))|(1<<(qasm3ParserImaginaryLiteral-65))|(1<<(qasm3ParserBinaryIntegerLiteral-65))|(1<<(qasm3ParserOctalIntegerLiteral-65))|(1<<(qasm3ParserDecimalIntegerLiteral-65))|(1<<(qasm3ParserHexIntegerLiteral-65))|(1<<(qasm3ParserIdentifier-65))|(1<<(qasm3ParserHardwareQubit-65))|(1<<(qasm3ParserFloatLiteral-65))|(1<<(qasm3ParserTimingLiteral-65))|(1<<(qasm3ParserBitstringLiteral-65)))) != 0) {
				{
					p.SetState(282)
					p.ExpressionList()
				}

			}
			{
				p.SetState(285)
				p.Match(qasm3ParserRPAREN)
			}

		}
		p.SetState(289)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(288)
				p.Designator()
			}

		}
		{
			p.SetState(291)
			p.GateOperandList()
		}
		{
			p.SetState(292)
			p.Match(qasm3ParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(297)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(qasm3ParserINV-40))|(1<<(qasm3ParserPOW-40))|(1<<(qasm3ParserCTRL-40))|(1<<(qasm3ParserNEGCTRL-40)))) != 0 {
			{
				p.SetState(294)
				p.GateModifier()
			}

			p.SetState(299)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(300)
			p.Match(qasm3ParserGPHASE)
		}
		p.SetState(306)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLPAREN {
			{
				p.SetState(301)
				p.Match(qasm3ParserLPAREN)
			}
			p.SetState(303)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(qasm3ParserBOOL-29))|(1<<(qasm3ParserBIT-29))|(1<<(qasm3ParserINT-29))|(1<<(qasm3ParserUINT-29))|(1<<(qasm3ParserFLOAT-29))|(1<<(qasm3ParserANGLE-29))|(1<<(qasm3ParserCOMPLEX-29))|(1<<(qasm3ParserARRAY-29))|(1<<(qasm3ParserDURATION-29))|(1<<(qasm3ParserSTRETCH-29))|(1<<(qasm3ParserDURATIONOF-29))|(1<<(qasm3ParserBooleanLiteral-29))|(1<<(qasm3ParserLPAREN-29)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(qasm3ParserMINUS-65))|(1<<(qasm3ParserTILDE-65))|(1<<(qasm3ParserEXCLAMATION_POINT-65))|(1<<(qasm3ParserImaginaryLiteral-65))|(1<<(qasm3ParserBinaryIntegerLiteral-65))|(1<<(qasm3ParserOctalIntegerLiteral-65))|(1<<(qasm3ParserDecimalIntegerLiteral-65))|(1<<(qasm3ParserHexIntegerLiteral-65))|(1<<(qasm3ParserIdentifier-65))|(1<<(qasm3ParserHardwareQubit-65))|(1<<(qasm3ParserFloatLiteral-65))|(1<<(qasm3ParserTimingLiteral-65))|(1<<(qasm3ParserBitstringLiteral-65)))) != 0) {
				{
					p.SetState(302)
					p.ExpressionList()
				}

			}
			{
				p.SetState(305)
				p.Match(qasm3ParserRPAREN)
			}

		}
		p.SetState(309)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(308)
				p.Designator()
			}

		}
		p.SetState(312)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserIdentifier || _la == qasm3ParserHardwareQubit {
			{
				p.SetState(311)
				p.GateOperandList()
			}

		}
		{
			p.SetState(314)
			p.Match(qasm3ParserSEMICOLON)
		}

	}

	return localctx
}

// IMeasureArrowAssignmentStatementContext is an interface to support dynamic dispatch.
type IMeasureArrowAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMeasureArrowAssignmentStatementContext differentiates from other interfaces.
	IsMeasureArrowAssignmentStatementContext()
}

type MeasureArrowAssignmentStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeasureArrowAssignmentStatementContext() *MeasureArrowAssignmentStatementContext {
	var p = new(MeasureArrowAssignmentStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_measureArrowAssignmentStatement
	return p
}

func (*MeasureArrowAssignmentStatementContext) IsMeasureArrowAssignmentStatementContext() {}

func NewMeasureArrowAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MeasureArrowAssignmentStatementContext {
	var p = new(MeasureArrowAssignmentStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_measureArrowAssignmentStatement

	return p
}

func (s *MeasureArrowAssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MeasureArrowAssignmentStatementContext) MeasureExpression() IMeasureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureExpressionContext)
}

func (s *MeasureArrowAssignmentStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *MeasureArrowAssignmentStatementContext) ARROW() antlr.TerminalNode {
	return s.GetToken(qasm3ParserARROW, 0)
}

func (s *MeasureArrowAssignmentStatementContext) IndexedIdentifier() IIndexedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexedIdentifierContext)
}

func (s *MeasureArrowAssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeasureArrowAssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MeasureArrowAssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterMeasureArrowAssignmentStatement(s)
	}
}

func (s *MeasureArrowAssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitMeasureArrowAssignmentStatement(s)
	}
}

func (s *MeasureArrowAssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitMeasureArrowAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) MeasureArrowAssignmentStatement() (localctx IMeasureArrowAssignmentStatementContext) {
	this := p
	_ = this

	localctx = NewMeasureArrowAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, qasm3ParserRULE_measureArrowAssignmentStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(317)
		p.MeasureExpression()
	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserARROW {
		{
			p.SetState(318)
			p.Match(qasm3ParserARROW)
		}
		{
			p.SetState(319)
			p.IndexedIdentifier()
		}

	}
	{
		p.SetState(322)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IResetStatementContext is an interface to support dynamic dispatch.
type IResetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResetStatementContext differentiates from other interfaces.
	IsResetStatementContext()
}

type ResetStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetStatementContext() *ResetStatementContext {
	var p = new(ResetStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_resetStatement
	return p
}

func (*ResetStatementContext) IsResetStatementContext() {}

func NewResetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetStatementContext {
	var p = new(ResetStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_resetStatement

	return p
}

func (s *ResetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetStatementContext) RESET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRESET, 0)
}

func (s *ResetStatementContext) GateOperand() IGateOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandContext)
}

func (s *ResetStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ResetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterResetStatement(s)
	}
}

func (s *ResetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitResetStatement(s)
	}
}

func (s *ResetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitResetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ResetStatement() (localctx IResetStatementContext) {
	this := p
	_ = this

	localctx = NewResetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, qasm3ParserRULE_resetStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)
		p.Match(qasm3ParserRESET)
	}
	{
		p.SetState(325)
		p.GateOperand()
	}
	{
		p.SetState(326)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IAliasDeclarationStatementContext is an interface to support dynamic dispatch.
type IAliasDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasDeclarationStatementContext differentiates from other interfaces.
	IsAliasDeclarationStatementContext()
}

type AliasDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasDeclarationStatementContext() *AliasDeclarationStatementContext {
	var p = new(AliasDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_aliasDeclarationStatement
	return p
}

func (*AliasDeclarationStatementContext) IsAliasDeclarationStatementContext() {}

func NewAliasDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasDeclarationStatementContext {
	var p = new(AliasDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_aliasDeclarationStatement

	return p
}

func (s *AliasDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasDeclarationStatementContext) LET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLET, 0)
}

func (s *AliasDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *AliasDeclarationStatementContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *AliasDeclarationStatementContext) AliasExpression() IAliasExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasExpressionContext)
}

func (s *AliasDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *AliasDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAliasDeclarationStatement(s)
	}
}

func (s *AliasDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAliasDeclarationStatement(s)
	}
}

func (s *AliasDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAliasDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) AliasDeclarationStatement() (localctx IAliasDeclarationStatementContext) {
	this := p
	_ = this

	localctx = NewAliasDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, qasm3ParserRULE_aliasDeclarationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(328)
		p.Match(qasm3ParserLET)
	}
	{
		p.SetState(329)
		p.Match(qasm3ParserIdentifier)
	}
	{
		p.SetState(330)
		p.Match(qasm3ParserEQUALS)
	}
	{
		p.SetState(331)
		p.AliasExpression()
	}
	{
		p.SetState(332)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IClassicalDeclarationStatementContext is an interface to support dynamic dispatch.
type IClassicalDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassicalDeclarationStatementContext differentiates from other interfaces.
	IsClassicalDeclarationStatementContext()
}

type ClassicalDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassicalDeclarationStatementContext() *ClassicalDeclarationStatementContext {
	var p = new(ClassicalDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_classicalDeclarationStatement
	return p
}

func (*ClassicalDeclarationStatementContext) IsClassicalDeclarationStatementContext() {}

func NewClassicalDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassicalDeclarationStatementContext {
	var p = new(ClassicalDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_classicalDeclarationStatement

	return p
}

func (s *ClassicalDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassicalDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *ClassicalDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ClassicalDeclarationStatementContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ClassicalDeclarationStatementContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ClassicalDeclarationStatementContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *ClassicalDeclarationStatementContext) DeclarationExpression() IDeclarationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationExpressionContext)
}

func (s *ClassicalDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassicalDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassicalDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterClassicalDeclarationStatement(s)
	}
}

func (s *ClassicalDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitClassicalDeclarationStatement(s)
	}
}

func (s *ClassicalDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitClassicalDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ClassicalDeclarationStatement() (localctx IClassicalDeclarationStatementContext) {
	this := p
	_ = this

	localctx = NewClassicalDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, qasm3ParserRULE_classicalDeclarationStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(336)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
		{
			p.SetState(334)
			p.ScalarType()
		}

	case qasm3ParserARRAY:
		{
			p.SetState(335)
			p.ArrayType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(338)
		p.Match(qasm3ParserIdentifier)
	}
	p.SetState(341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserEQUALS {
		{
			p.SetState(339)
			p.Match(qasm3ParserEQUALS)
		}
		{
			p.SetState(340)
			p.DeclarationExpression()
		}

	}
	{
		p.SetState(343)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IConstDeclarationStatementContext is an interface to support dynamic dispatch.
type IConstDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstDeclarationStatementContext differentiates from other interfaces.
	IsConstDeclarationStatementContext()
}

type ConstDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstDeclarationStatementContext() *ConstDeclarationStatementContext {
	var p = new(ConstDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_constDeclarationStatement
	return p
}

func (*ConstDeclarationStatementContext) IsConstDeclarationStatementContext() {}

func NewConstDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclarationStatementContext {
	var p = new(ConstDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_constDeclarationStatement

	return p
}

func (s *ConstDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclarationStatementContext) CONST() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCONST, 0)
}

func (s *ConstDeclarationStatementContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ConstDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *ConstDeclarationStatementContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *ConstDeclarationStatementContext) DeclarationExpression() IDeclarationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationExpressionContext)
}

func (s *ConstDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ConstDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterConstDeclarationStatement(s)
	}
}

func (s *ConstDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitConstDeclarationStatement(s)
	}
}

func (s *ConstDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitConstDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ConstDeclarationStatement() (localctx IConstDeclarationStatementContext) {
	this := p
	_ = this

	localctx = NewConstDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, qasm3ParserRULE_constDeclarationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(345)
		p.Match(qasm3ParserCONST)
	}
	{
		p.SetState(346)
		p.ScalarType()
	}
	{
		p.SetState(347)
		p.Match(qasm3ParserIdentifier)
	}
	{
		p.SetState(348)
		p.Match(qasm3ParserEQUALS)
	}
	{
		p.SetState(349)
		p.DeclarationExpression()
	}
	{
		p.SetState(350)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IIoDeclarationStatementContext is an interface to support dynamic dispatch.
type IIoDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIoDeclarationStatementContext differentiates from other interfaces.
	IsIoDeclarationStatementContext()
}

type IoDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIoDeclarationStatementContext() *IoDeclarationStatementContext {
	var p = new(IoDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_ioDeclarationStatement
	return p
}

func (*IoDeclarationStatementContext) IsIoDeclarationStatementContext() {}

func NewIoDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IoDeclarationStatementContext {
	var p = new(IoDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_ioDeclarationStatement

	return p
}

func (s *IoDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IoDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *IoDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *IoDeclarationStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserINPUT, 0)
}

func (s *IoDeclarationStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserOUTPUT, 0)
}

func (s *IoDeclarationStatementContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *IoDeclarationStatementContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *IoDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IoDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IoDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIoDeclarationStatement(s)
	}
}

func (s *IoDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIoDeclarationStatement(s)
	}
}

func (s *IoDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIoDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IoDeclarationStatement() (localctx IIoDeclarationStatementContext) {
	this := p
	_ = this

	localctx = NewIoDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, qasm3ParserRULE_ioDeclarationStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(352)
		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserINPUT || _la == qasm3ParserOUTPUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(355)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
		{
			p.SetState(353)
			p.ScalarType()
		}

	case qasm3ParserARRAY:
		{
			p.SetState(354)
			p.ArrayType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(357)
		p.Match(qasm3ParserIdentifier)
	}
	{
		p.SetState(358)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IOldStyleDeclarationStatementContext is an interface to support dynamic dispatch.
type IOldStyleDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOldStyleDeclarationStatementContext differentiates from other interfaces.
	IsOldStyleDeclarationStatementContext()
}

type OldStyleDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOldStyleDeclarationStatementContext() *OldStyleDeclarationStatementContext {
	var p = new(OldStyleDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_oldStyleDeclarationStatement
	return p
}

func (*OldStyleDeclarationStatementContext) IsOldStyleDeclarationStatementContext() {}

func NewOldStyleDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OldStyleDeclarationStatementContext {
	var p = new(OldStyleDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_oldStyleDeclarationStatement

	return p
}

func (s *OldStyleDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OldStyleDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *OldStyleDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *OldStyleDeclarationStatementContext) CREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCREG, 0)
}

func (s *OldStyleDeclarationStatementContext) QREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserQREG, 0)
}

func (s *OldStyleDeclarationStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *OldStyleDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OldStyleDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OldStyleDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterOldStyleDeclarationStatement(s)
	}
}

func (s *OldStyleDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitOldStyleDeclarationStatement(s)
	}
}

func (s *OldStyleDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitOldStyleDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) OldStyleDeclarationStatement() (localctx IOldStyleDeclarationStatementContext) {
	this := p
	_ = this

	localctx = NewOldStyleDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, qasm3ParserRULE_oldStyleDeclarationStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserQREG || _la == qasm3ParserCREG) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(361)
		p.Match(qasm3ParserIdentifier)
	}
	p.SetState(363)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLBRACKET {
		{
			p.SetState(362)
			p.Designator()
		}

	}
	{
		p.SetState(365)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IQuantumDeclarationStatementContext is an interface to support dynamic dispatch.
type IQuantumDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantumDeclarationStatementContext differentiates from other interfaces.
	IsQuantumDeclarationStatementContext()
}

type QuantumDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantumDeclarationStatementContext() *QuantumDeclarationStatementContext {
	var p = new(QuantumDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_quantumDeclarationStatement
	return p
}

func (*QuantumDeclarationStatementContext) IsQuantumDeclarationStatementContext() {}

func NewQuantumDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantumDeclarationStatementContext {
	var p = new(QuantumDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_quantumDeclarationStatement

	return p
}

func (s *QuantumDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantumDeclarationStatementContext) QubitType() IQubitTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQubitTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQubitTypeContext)
}

func (s *QuantumDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *QuantumDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *QuantumDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantumDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantumDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterQuantumDeclarationStatement(s)
	}
}

func (s *QuantumDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitQuantumDeclarationStatement(s)
	}
}

func (s *QuantumDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitQuantumDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) QuantumDeclarationStatement() (localctx IQuantumDeclarationStatementContext) {
	this := p
	_ = this

	localctx = NewQuantumDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, qasm3ParserRULE_quantumDeclarationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.QubitType()
	}
	{
		p.SetState(368)
		p.Match(qasm3ParserIdentifier)
	}
	{
		p.SetState(369)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IDefStatementContext is an interface to support dynamic dispatch.
type IDefStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefStatementContext differentiates from other interfaces.
	IsDefStatementContext()
}

type DefStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefStatementContext() *DefStatementContext {
	var p = new(DefStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_defStatement
	return p
}

func (*DefStatementContext) IsDefStatementContext() {}

func NewDefStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefStatementContext {
	var p = new(DefStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defStatement

	return p
}

func (s *DefStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DefStatementContext) DEF() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDEF, 0)
}

func (s *DefStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *DefStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *DefStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *DefStatementContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *DefStatementContext) ArgumentDefinitionList() IArgumentDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentDefinitionListContext)
}

func (s *DefStatementContext) ReturnSignature() IReturnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnSignatureContext)
}

func (s *DefStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefStatement(s)
	}
}

func (s *DefStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefStatement(s)
	}
}

func (s *DefStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefStatement() (localctx IDefStatementContext) {
	this := p
	_ = this

	localctx = NewDefStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, qasm3ParserRULE_defStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(qasm3ParserDEF)
	}
	{
		p.SetState(372)
		p.Match(qasm3ParserIdentifier)
	}
	{
		p.SetState(373)
		p.Match(qasm3ParserLPAREN)
	}
	p.SetState(375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-24)&-(0x1f+1)) == 0 && ((1<<uint((_la-24)))&((1<<(qasm3ParserCONST-24))|(1<<(qasm3ParserMUTABLE-24))|(1<<(qasm3ParserQREG-24))|(1<<(qasm3ParserQUBIT-24))|(1<<(qasm3ParserCREG-24))|(1<<(qasm3ParserBOOL-24))|(1<<(qasm3ParserBIT-24))|(1<<(qasm3ParserINT-24))|(1<<(qasm3ParserUINT-24))|(1<<(qasm3ParserFLOAT-24))|(1<<(qasm3ParserANGLE-24))|(1<<(qasm3ParserCOMPLEX-24))|(1<<(qasm3ParserDURATION-24))|(1<<(qasm3ParserSTRETCH-24)))) != 0 {
		{
			p.SetState(374)
			p.ArgumentDefinitionList()
		}

	}
	{
		p.SetState(377)
		p.Match(qasm3ParserRPAREN)
	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserARROW {
		{
			p.SetState(378)
			p.ReturnSignature()
		}

	}
	{
		p.SetState(381)
		p.Scope()
	}

	return localctx
}

// IExternStatementContext is an interface to support dynamic dispatch.
type IExternStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternStatementContext differentiates from other interfaces.
	IsExternStatementContext()
}

type ExternStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternStatementContext() *ExternStatementContext {
	var p = new(ExternStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_externStatement
	return p
}

func (*ExternStatementContext) IsExternStatementContext() {}

func NewExternStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternStatementContext {
	var p = new(ExternStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_externStatement

	return p
}

func (s *ExternStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternStatementContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEXTERN, 0)
}

func (s *ExternStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *ExternStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *ExternStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *ExternStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ExternStatementContext) ExternArgumentList() IExternArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternArgumentListContext)
}

func (s *ExternStatementContext) ReturnSignature() IReturnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnSignatureContext)
}

func (s *ExternStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExternStatement(s)
	}
}

func (s *ExternStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExternStatement(s)
	}
}

func (s *ExternStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExternStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExternStatement() (localctx IExternStatementContext) {
	this := p
	_ = this

	localctx = NewExternStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, qasm3ParserRULE_externStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(383)
		p.Match(qasm3ParserEXTERN)
	}
	{
		p.SetState(384)
		p.Match(qasm3ParserIdentifier)
	}
	{
		p.SetState(385)
		p.Match(qasm3ParserLPAREN)
	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-24)&-(0x1f+1)) == 0 && ((1<<uint((_la-24)))&((1<<(qasm3ParserCONST-24))|(1<<(qasm3ParserMUTABLE-24))|(1<<(qasm3ParserCREG-24))|(1<<(qasm3ParserBOOL-24))|(1<<(qasm3ParserBIT-24))|(1<<(qasm3ParserINT-24))|(1<<(qasm3ParserUINT-24))|(1<<(qasm3ParserFLOAT-24))|(1<<(qasm3ParserANGLE-24))|(1<<(qasm3ParserCOMPLEX-24))|(1<<(qasm3ParserDURATION-24))|(1<<(qasm3ParserSTRETCH-24)))) != 0 {
		{
			p.SetState(386)
			p.ExternArgumentList()
		}

	}
	{
		p.SetState(389)
		p.Match(qasm3ParserRPAREN)
	}
	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserARROW {
		{
			p.SetState(390)
			p.ReturnSignature()
		}

	}
	{
		p.SetState(393)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IGateStatementContext is an interface to support dynamic dispatch.
type IGateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParams returns the params rule contexts.
	GetParams() IIdentifierListContext

	// GetQubits returns the qubits rule contexts.
	GetQubits() IIdentifierListContext

	// SetParams sets the params rule contexts.
	SetParams(IIdentifierListContext)

	// SetQubits sets the qubits rule contexts.
	SetQubits(IIdentifierListContext)

	// IsGateStatementContext differentiates from other interfaces.
	IsGateStatementContext()
}

type GateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	params IIdentifierListContext
	qubits IIdentifierListContext
}

func NewEmptyGateStatementContext() *GateStatementContext {
	var p = new(GateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateStatement
	return p
}

func (*GateStatementContext) IsGateStatementContext() {}

func NewGateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateStatementContext {
	var p = new(GateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateStatement

	return p
}

func (s *GateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GateStatementContext) GetParams() IIdentifierListContext { return s.params }

func (s *GateStatementContext) GetQubits() IIdentifierListContext { return s.qubits }

func (s *GateStatementContext) SetParams(v IIdentifierListContext) { s.params = v }

func (s *GateStatementContext) SetQubits(v IIdentifierListContext) { s.qubits = v }

func (s *GateStatementContext) GATE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserGATE, 0)
}

func (s *GateStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *GateStatementContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *GateStatementContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *GateStatementContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *GateStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *GateStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *GateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateStatement(s)
	}
}

func (s *GateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateStatement(s)
	}
}

func (s *GateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateStatement() (localctx IGateStatementContext) {
	this := p
	_ = this

	localctx = NewGateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, qasm3ParserRULE_gateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(395)
		p.Match(qasm3ParserGATE)
	}
	{
		p.SetState(396)
		p.Match(qasm3ParserIdentifier)
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLPAREN {
		{
			p.SetState(397)
			p.Match(qasm3ParserLPAREN)
		}
		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserIdentifier {
			{
				p.SetState(398)

				var _x = p.IdentifierList()

				localctx.(*GateStatementContext).params = _x
			}

		}
		{
			p.SetState(401)
			p.Match(qasm3ParserRPAREN)
		}

	}
	{
		p.SetState(404)

		var _x = p.IdentifierList()

		localctx.(*GateStatementContext).qubits = _x
	}
	{
		p.SetState(405)
		p.Scope()
	}

	return localctx
}

// IAssignmentStatementContext is an interface to support dynamic dispatch.
type IAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsAssignmentStatementContext differentiates from other interfaces.
	IsAssignmentStatementContext()
}

type AssignmentStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyAssignmentStatementContext() *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_assignmentStatement
	return p
}

func (*AssignmentStatementContext) IsAssignmentStatementContext() {}

func NewAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_assignmentStatement

	return p
}

func (s *AssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentStatementContext) GetOp() antlr.Token { return s.op }

func (s *AssignmentStatementContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignmentStatementContext) IndexedIdentifier() IIndexedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexedIdentifierContext)
}

func (s *AssignmentStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *AssignmentStatementContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *AssignmentStatementContext) CompoundAssignmentOperator() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCompoundAssignmentOperator, 0)
}

func (s *AssignmentStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) MeasureExpression() IMeasureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureExpressionContext)
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) AssignmentStatement() (localctx IAssignmentStatementContext) {
	this := p
	_ = this

	localctx = NewAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, qasm3ParserRULE_assignmentStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.IndexedIdentifier()
	}
	{
		p.SetState(408)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AssignmentStatementContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserEQUALS || _la == qasm3ParserCompoundAssignmentOperator) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AssignmentStatementContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		{
			p.SetState(409)
			p.expression(0)
		}

	case qasm3ParserMEASURE:
		{
			p.SetState(410)
			p.MeasureExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(413)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, qasm3ParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.expression(0)
	}
	{
		p.SetState(416)
		p.Match(qasm3ParserSEMICOLON)
	}

	return localctx
}

// ICalStatementContext is an interface to support dynamic dispatch.
type ICalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCalStatementContext differentiates from other interfaces.
	IsCalStatementContext()
}

type CalStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalStatementContext() *CalStatementContext {
	var p = new(CalStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_calStatement
	return p
}

func (*CalStatementContext) IsCalStatementContext() {}

func NewCalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalStatementContext {
	var p = new(CalStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_calStatement

	return p
}

func (s *CalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CalStatementContext) CAL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCAL, 0)
}

func (s *CalStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *CalStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *CalStatementContext) CalibrationBlock() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCalibrationBlock, 0)
}

func (s *CalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterCalStatement(s)
	}
}

func (s *CalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitCalStatement(s)
	}
}

func (s *CalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitCalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) CalStatement() (localctx ICalStatementContext) {
	this := p
	_ = this

	localctx = NewCalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, qasm3ParserRULE_calStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(418)
		p.Match(qasm3ParserCAL)
	}
	{
		p.SetState(419)
		p.Match(qasm3ParserLBRACE)
	}
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCalibrationBlock {
		{
			p.SetState(420)
			p.Match(qasm3ParserCalibrationBlock)
		}

	}
	{
		p.SetState(423)
		p.Match(qasm3ParserRBRACE)
	}

	return localctx
}

// IDefcalStatementContext is an interface to support dynamic dispatch.
type IDefcalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefcalStatementContext differentiates from other interfaces.
	IsDefcalStatementContext()
}

type DefcalStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalStatementContext() *DefcalStatementContext {
	var p = new(DefcalStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalStatement
	return p
}

func (*DefcalStatementContext) IsDefcalStatementContext() {}

func NewDefcalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalStatementContext {
	var p = new(DefcalStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalStatement

	return p
}

func (s *DefcalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalStatementContext) DEFCAL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDEFCAL, 0)
}

func (s *DefcalStatementContext) DefcalTarget() IDefcalTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalTargetContext)
}

func (s *DefcalStatementContext) DefcalOperandList() IDefcalOperandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalOperandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalOperandListContext)
}

func (s *DefcalStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *DefcalStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *DefcalStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *DefcalStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *DefcalStatementContext) ReturnSignature() IReturnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnSignatureContext)
}

func (s *DefcalStatementContext) CalibrationBlock() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCalibrationBlock, 0)
}

func (s *DefcalStatementContext) DefcalArgumentDefinitionList() IDefcalArgumentDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalArgumentDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalArgumentDefinitionListContext)
}

func (s *DefcalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalStatement(s)
	}
}

func (s *DefcalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalStatement(s)
	}
}

func (s *DefcalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalStatement() (localctx IDefcalStatementContext) {
	this := p
	_ = this

	localctx = NewDefcalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, qasm3ParserRULE_defcalStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)
		p.Match(qasm3ParserDEFCAL)
	}
	{
		p.SetState(426)
		p.DefcalTarget()
	}
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLPAREN {
		{
			p.SetState(427)
			p.Match(qasm3ParserLPAREN)
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-24)&-(0x1f+1)) == 0 && ((1<<uint((_la-24)))&((1<<(qasm3ParserCONST-24))|(1<<(qasm3ParserMUTABLE-24))|(1<<(qasm3ParserQREG-24))|(1<<(qasm3ParserQUBIT-24))|(1<<(qasm3ParserCREG-24))|(1<<(qasm3ParserBOOL-24))|(1<<(qasm3ParserBIT-24))|(1<<(qasm3ParserINT-24))|(1<<(qasm3ParserUINT-24))|(1<<(qasm3ParserFLOAT-24))|(1<<(qasm3ParserANGLE-24))|(1<<(qasm3ParserCOMPLEX-24))|(1<<(qasm3ParserARRAY-24))|(1<<(qasm3ParserDURATION-24))|(1<<(qasm3ParserSTRETCH-24))|(1<<(qasm3ParserDURATIONOF-24))|(1<<(qasm3ParserBooleanLiteral-24))|(1<<(qasm3ParserLPAREN-24)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(qasm3ParserMINUS-65))|(1<<(qasm3ParserTILDE-65))|(1<<(qasm3ParserEXCLAMATION_POINT-65))|(1<<(qasm3ParserImaginaryLiteral-65))|(1<<(qasm3ParserBinaryIntegerLiteral-65))|(1<<(qasm3ParserOctalIntegerLiteral-65))|(1<<(qasm3ParserDecimalIntegerLiteral-65))|(1<<(qasm3ParserHexIntegerLiteral-65))|(1<<(qasm3ParserIdentifier-65))|(1<<(qasm3ParserHardwareQubit-65))|(1<<(qasm3ParserFloatLiteral-65))|(1<<(qasm3ParserTimingLiteral-65))|(1<<(qasm3ParserBitstringLiteral-65)))) != 0) {
			{
				p.SetState(428)
				p.DefcalArgumentDefinitionList()
			}

		}
		{
			p.SetState(431)
			p.Match(qasm3ParserRPAREN)
		}

	}
	{
		p.SetState(434)
		p.DefcalOperandList()
	}
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserARROW {
		{
			p.SetState(435)
			p.ReturnSignature()
		}

	}
	{
		p.SetState(438)
		p.Match(qasm3ParserLBRACE)
	}
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCalibrationBlock {
		{
			p.SetState(439)
			p.Match(qasm3ParserCalibrationBlock)
		}

	}
	{
		p.SetState(442)
		p.Match(qasm3ParserRBRACE)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BitwiseXorExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewBitwiseXorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseXorExpressionContext {
	var p = new(BitwiseXorExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseXorExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseXorExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseXorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseXorExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseXorExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCARET, 0)
}

func (s *BitwiseXorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBitwiseXorExpression(s)
	}
}

func (s *BitwiseXorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBitwiseXorExpression(s)
	}
}

func (s *BitwiseXorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBitwiseXorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdditiveExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewAdditiveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AdditiveExpressionContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdditiveExpressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPLUS, 0)
}

func (s *AdditiveExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMINUS, 0)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type DurationofExpressionContext struct {
	*ExpressionContext
}

func NewDurationofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DurationofExpressionContext {
	var p = new(DurationofExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *DurationofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationofExpressionContext) DURATIONOF() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDURATIONOF, 0)
}

func (s *DurationofExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *DurationofExpressionContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *DurationofExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *DurationofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDurationofExpression(s)
	}
}

func (s *DurationofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDurationofExpression(s)
	}
}

func (s *DurationofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDurationofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesisExpressionContext struct {
	*ExpressionContext
}

func NewParenthesisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisExpressionContext {
	var p = new(ParenthesisExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ParenthesisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *ParenthesisExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesisExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *ParenthesisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterParenthesisExpression(s)
	}
}

func (s *ParenthesisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitParenthesisExpression(s)
	}
}

func (s *ParenthesisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitParenthesisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComparisonExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewComparisonExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ComparisonExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ComparisonExpressionContext) ComparisonOperator() antlr.TerminalNode {
	return s.GetToken(qasm3ParserComparisonOperator, 0)
}

func (s *ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitComparisonExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiplicativeExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewMultiplicativeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *MultiplicativeExpressionContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiplicativeExpressionContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(qasm3ParserASTERISK, 0)
}

func (s *MultiplicativeExpressionContext) SLASH() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSLASH, 0)
}

func (s *MultiplicativeExpressionContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPERCENT, 0)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalOrExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewLogicalOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalOrExpressionContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalOrExpressionContext) DOUBLE_PIPE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDOUBLE_PIPE, 0)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitLogicalOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastExpressionContext struct {
	*ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *CastExpressionContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *CastExpressionContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PowerExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewPowerExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExpressionContext {
	var p = new(PowerExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PowerExpressionContext) GetOp() antlr.Token { return s.op }

func (s *PowerExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *PowerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PowerExpressionContext) DOUBLE_ASTERISK() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDOUBLE_ASTERISK, 0)
}

func (s *PowerExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterPowerExpression(s)
	}
}

func (s *PowerExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitPowerExpression(s)
	}
}

func (s *PowerExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitPowerExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseOrExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewBitwiseOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseOrExpressionContext {
	var p = new(BitwiseOrExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseOrExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseOrExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseOrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseOrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseOrExpressionContext) PIPE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPIPE, 0)
}

func (s *BitwiseOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBitwiseOrExpression(s)
	}
}

func (s *BitwiseOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBitwiseOrExpression(s)
	}
}

func (s *BitwiseOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBitwiseOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CallExpressionContext struct {
	*ExpressionContext
}

func NewCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallExpressionContext {
	var p = new(CallExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *CallExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *CallExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *CallExpressionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *CallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterCallExpression(s)
	}
}

func (s *CallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitCallExpression(s)
	}
}

func (s *CallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitshiftExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewBitshiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitshiftExpressionContext {
	var p = new(BitshiftExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BitshiftExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitshiftExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitshiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitshiftExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitshiftExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitshiftExpressionContext) BitshiftOperator() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBitshiftOperator, 0)
}

func (s *BitshiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBitshiftExpression(s)
	}
}

func (s *BitshiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBitshiftExpression(s)
	}
}

func (s *BitshiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBitshiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseAndExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewBitwiseAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseAndExpressionContext {
	var p = new(BitwiseAndExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseAndExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseAndExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseAndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseAndExpressionContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(qasm3ParserAMPERSAND, 0)
}

func (s *BitwiseAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBitwiseAndExpression(s)
	}
}

func (s *BitwiseAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBitwiseAndExpression(s)
	}
}

func (s *BitwiseAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBitwiseAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityExpressionContext) EqualityOperator() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEqualityOperator, 0)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalAndExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewLogicalAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalAndExpressionContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalAndExpressionContext) DOUBLE_AMPERSAND() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDOUBLE_AMPERSAND, 0)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitLogicalAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IndexExpressionContext struct {
	*ExpressionContext
}

func NewIndexExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexExpressionContext {
	var p = new(IndexExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexExpressionContext) IndexOperator() IIndexOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOperatorContext)
}

func (s *IndexExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIndexExpression(s)
	}
}

func (s *IndexExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIndexExpression(s)
	}
}

func (s *IndexExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIndexExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewUnaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryExpressionContext) GetOp() antlr.Token { return s.op }

func (s *UnaryExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryExpressionContext) TILDE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserTILDE, 0)
}

func (s *UnaryExpressionContext) EXCLAMATION_POINT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEXCLAMATION_POINT, 0)
}

func (s *UnaryExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMINUS, 0)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralExpressionContext struct {
	*ExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *LiteralExpressionContext) BinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBinaryIntegerLiteral, 0)
}

func (s *LiteralExpressionContext) OctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserOctalIntegerLiteral, 0)
}

func (s *LiteralExpressionContext) DecimalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDecimalIntegerLiteral, 0)
}

func (s *LiteralExpressionContext) HexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserHexIntegerLiteral, 0)
}

func (s *LiteralExpressionContext) FloatLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserFloatLiteral, 0)
}

func (s *LiteralExpressionContext) ImaginaryLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserImaginaryLiteral, 0)
}

func (s *LiteralExpressionContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBooleanLiteral, 0)
}

func (s *LiteralExpressionContext) BitstringLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBitstringLiteral, 0)
}

func (s *LiteralExpressionContext) TimingLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserTimingLiteral, 0)
}

func (s *LiteralExpressionContext) HardwareQubit() antlr.TerminalNode {
	return s.GetToken(qasm3ParserHardwareQubit, 0)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *qasm3Parser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 70
	p.EnterRecursionRule(localctx, 70, qasm3ParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenthesisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(445)
			p.Match(qasm3ParserLPAREN)
		}
		{
			p.SetState(446)
			p.expression(0)
		}
		{
			p.SetState(447)
			p.Match(qasm3ParserRPAREN)
		}

	case 2:
		localctx = NewUnaryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(449)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryExpressionContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(qasm3ParserMINUS-65))|(1<<(qasm3ParserTILDE-65))|(1<<(qasm3ParserEXCLAMATION_POINT-65)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryExpressionContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(450)
			p.expression(15)
		}

	case 3:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(453)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
			{
				p.SetState(451)
				p.ScalarType()
			}

		case qasm3ParserARRAY:
			{
				p.SetState(452)
				p.ArrayType()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(455)
			p.Match(qasm3ParserLPAREN)
		}
		{
			p.SetState(456)
			p.expression(0)
		}
		{
			p.SetState(457)
			p.Match(qasm3ParserRPAREN)
		}

	case 4:
		localctx = NewDurationofExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(459)
			p.Match(qasm3ParserDURATIONOF)
		}
		{
			p.SetState(460)
			p.Match(qasm3ParserLPAREN)
		}
		{
			p.SetState(461)
			p.Scope()
		}
		{
			p.SetState(462)
			p.Match(qasm3ParserRPAREN)
		}

	case 5:
		localctx = NewCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(464)
			p.Match(qasm3ParserIdentifier)
		}
		{
			p.SetState(465)
			p.Match(qasm3ParserLPAREN)
		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(qasm3ParserBOOL-29))|(1<<(qasm3ParserBIT-29))|(1<<(qasm3ParserINT-29))|(1<<(qasm3ParserUINT-29))|(1<<(qasm3ParserFLOAT-29))|(1<<(qasm3ParserANGLE-29))|(1<<(qasm3ParserCOMPLEX-29))|(1<<(qasm3ParserARRAY-29))|(1<<(qasm3ParserDURATION-29))|(1<<(qasm3ParserSTRETCH-29))|(1<<(qasm3ParserDURATIONOF-29))|(1<<(qasm3ParserBooleanLiteral-29))|(1<<(qasm3ParserLPAREN-29)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(qasm3ParserMINUS-65))|(1<<(qasm3ParserTILDE-65))|(1<<(qasm3ParserEXCLAMATION_POINT-65))|(1<<(qasm3ParserImaginaryLiteral-65))|(1<<(qasm3ParserBinaryIntegerLiteral-65))|(1<<(qasm3ParserOctalIntegerLiteral-65))|(1<<(qasm3ParserDecimalIntegerLiteral-65))|(1<<(qasm3ParserHexIntegerLiteral-65))|(1<<(qasm3ParserIdentifier-65))|(1<<(qasm3ParserHardwareQubit-65))|(1<<(qasm3ParserFloatLiteral-65))|(1<<(qasm3ParserTimingLiteral-65))|(1<<(qasm3ParserBitstringLiteral-65)))) != 0) {
			{
				p.SetState(466)
				p.ExpressionList()
			}

		}
		{
			p.SetState(469)
			p.Match(qasm3ParserRPAREN)
		}

	case 6:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(470)
			_la = p.GetTokenStream().LA(1)

			if !(_la == qasm3ParserBooleanLiteral || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(qasm3ParserImaginaryLiteral-83))|(1<<(qasm3ParserBinaryIntegerLiteral-83))|(1<<(qasm3ParserOctalIntegerLiteral-83))|(1<<(qasm3ParserDecimalIntegerLiteral-83))|(1<<(qasm3ParserHexIntegerLiteral-83))|(1<<(qasm3ParserIdentifier-83))|(1<<(qasm3ParserHardwareQubit-83))|(1<<(qasm3ParserFloatLiteral-83))|(1<<(qasm3ParserTimingLiteral-83))|(1<<(qasm3ParserBitstringLiteral-83)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(508)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(473)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(474)

					var _m = p.Match(qasm3ParserDOUBLE_ASTERISK)

					localctx.(*PowerExpressionContext).op = _m
				}
				{
					p.SetState(475)
					p.expression(16)
				}

			case 2:
				localctx = NewMultiplicativeExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(476)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(477)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*MultiplicativeExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(qasm3ParserASTERISK-66))|(1<<(qasm3ParserSLASH-66))|(1<<(qasm3ParserPERCENT-66)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*MultiplicativeExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(478)
					p.expression(15)
				}

			case 3:
				localctx = NewAdditiveExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(479)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(480)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AdditiveExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == qasm3ParserPLUS || _la == qasm3ParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AdditiveExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(481)
					p.expression(14)
				}

			case 4:
				localctx = NewBitshiftExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(482)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(483)

					var _m = p.Match(qasm3ParserBitshiftOperator)

					localctx.(*BitshiftExpressionContext).op = _m
				}
				{
					p.SetState(484)
					p.expression(13)
				}

			case 5:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(485)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(486)

					var _m = p.Match(qasm3ParserComparisonOperator)

					localctx.(*ComparisonExpressionContext).op = _m
				}
				{
					p.SetState(487)
					p.expression(12)
				}

			case 6:
				localctx = NewEqualityExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(488)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(489)

					var _m = p.Match(qasm3ParserEqualityOperator)

					localctx.(*EqualityExpressionContext).op = _m
				}
				{
					p.SetState(490)
					p.expression(11)
				}

			case 7:
				localctx = NewBitwiseAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(491)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(492)

					var _m = p.Match(qasm3ParserAMPERSAND)

					localctx.(*BitwiseAndExpressionContext).op = _m
				}
				{
					p.SetState(493)
					p.expression(10)
				}

			case 8:
				localctx = NewBitwiseXorExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(494)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(495)

					var _m = p.Match(qasm3ParserCARET)

					localctx.(*BitwiseXorExpressionContext).op = _m
				}
				{
					p.SetState(496)
					p.expression(9)
				}

			case 9:
				localctx = NewBitwiseOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(497)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(498)

					var _m = p.Match(qasm3ParserPIPE)

					localctx.(*BitwiseOrExpressionContext).op = _m
				}
				{
					p.SetState(499)
					p.expression(8)
				}

			case 10:
				localctx = NewLogicalAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(500)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(501)

					var _m = p.Match(qasm3ParserDOUBLE_AMPERSAND)

					localctx.(*LogicalAndExpressionContext).op = _m
				}
				{
					p.SetState(502)
					p.expression(7)
				}

			case 11:
				localctx = NewLogicalOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(503)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(504)

					var _m = p.Match(qasm3ParserDOUBLE_PIPE)

					localctx.(*LogicalOrExpressionContext).op = _m
				}
				{
					p.SetState(505)
					p.expression(6)
				}

			case 12:
				localctx = NewIndexExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(506)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(507)
					p.IndexOperator()
				}

			}

		}
		p.SetState(512)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())
	}

	return localctx
}

// IAliasExpressionContext is an interface to support dynamic dispatch.
type IAliasExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasExpressionContext differentiates from other interfaces.
	IsAliasExpressionContext()
}

type AliasExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasExpressionContext() *AliasExpressionContext {
	var p = new(AliasExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_aliasExpression
	return p
}

func (*AliasExpressionContext) IsAliasExpressionContext() {}

func NewAliasExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasExpressionContext {
	var p = new(AliasExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_aliasExpression

	return p
}

func (s *AliasExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AliasExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AliasExpressionContext) AllDOUBLE_PLUS() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserDOUBLE_PLUS)
}

func (s *AliasExpressionContext) DOUBLE_PLUS(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserDOUBLE_PLUS, i)
}

func (s *AliasExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAliasExpression(s)
	}
}

func (s *AliasExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAliasExpression(s)
	}
}

func (s *AliasExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAliasExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) AliasExpression() (localctx IAliasExpressionContext) {
	this := p
	_ = this

	localctx = NewAliasExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, qasm3ParserRULE_aliasExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.expression(0)
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == qasm3ParserDOUBLE_PLUS {
		{
			p.SetState(514)
			p.Match(qasm3ParserDOUBLE_PLUS)
		}
		{
			p.SetState(515)
			p.expression(0)
		}

		p.SetState(520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclarationExpressionContext is an interface to support dynamic dispatch.
type IDeclarationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationExpressionContext differentiates from other interfaces.
	IsDeclarationExpressionContext()
}

type DeclarationExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationExpressionContext() *DeclarationExpressionContext {
	var p = new(DeclarationExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_declarationExpression
	return p
}

func (*DeclarationExpressionContext) IsDeclarationExpressionContext() {}

func NewDeclarationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationExpressionContext {
	var p = new(DeclarationExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_declarationExpression

	return p
}

func (s *DeclarationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *DeclarationExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeclarationExpressionContext) MeasureExpression() IMeasureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureExpressionContext)
}

func (s *DeclarationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDeclarationExpression(s)
	}
}

func (s *DeclarationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDeclarationExpression(s)
	}
}

func (s *DeclarationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDeclarationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DeclarationExpression() (localctx IDeclarationExpressionContext) {
	this := p
	_ = this

	localctx = NewDeclarationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, qasm3ParserRULE_declarationExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(524)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(521)
			p.ArrayLiteral()
		}

	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(522)
			p.expression(0)
		}

	case qasm3ParserMEASURE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(523)
			p.MeasureExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMeasureExpressionContext is an interface to support dynamic dispatch.
type IMeasureExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMeasureExpressionContext differentiates from other interfaces.
	IsMeasureExpressionContext()
}

type MeasureExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeasureExpressionContext() *MeasureExpressionContext {
	var p = new(MeasureExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_measureExpression
	return p
}

func (*MeasureExpressionContext) IsMeasureExpressionContext() {}

func NewMeasureExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MeasureExpressionContext {
	var p = new(MeasureExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_measureExpression

	return p
}

func (s *MeasureExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MeasureExpressionContext) MEASURE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMEASURE, 0)
}

func (s *MeasureExpressionContext) GateOperand() IGateOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandContext)
}

func (s *MeasureExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeasureExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MeasureExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterMeasureExpression(s)
	}
}

func (s *MeasureExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitMeasureExpression(s)
	}
}

func (s *MeasureExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitMeasureExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) MeasureExpression() (localctx IMeasureExpressionContext) {
	this := p
	_ = this

	localctx = NewMeasureExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, qasm3ParserRULE_measureExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)
		p.Match(qasm3ParserMEASURE)
	}
	{
		p.SetState(527)
		p.GateOperand()
	}

	return localctx
}

// IRangeExpressionContext is an interface to support dynamic dispatch.
type IRangeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeExpressionContext differentiates from other interfaces.
	IsRangeExpressionContext()
}

type RangeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExpressionContext() *RangeExpressionContext {
	var p = new(RangeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_rangeExpression
	return p
}

func (*RangeExpressionContext) IsRangeExpressionContext() {}

func NewRangeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExpressionContext {
	var p = new(RangeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_rangeExpression

	return p
}

func (s *RangeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExpressionContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOLON)
}

func (s *RangeExpressionContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOLON, i)
}

func (s *RangeExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RangeExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterRangeExpression(s)
	}
}

func (s *RangeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitRangeExpression(s)
	}
}

func (s *RangeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitRangeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) RangeExpression() (localctx IRangeExpressionContext) {
	this := p
	_ = this

	localctx = NewRangeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, qasm3ParserRULE_rangeExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(qasm3ParserBOOL-29))|(1<<(qasm3ParserBIT-29))|(1<<(qasm3ParserINT-29))|(1<<(qasm3ParserUINT-29))|(1<<(qasm3ParserFLOAT-29))|(1<<(qasm3ParserANGLE-29))|(1<<(qasm3ParserCOMPLEX-29))|(1<<(qasm3ParserARRAY-29))|(1<<(qasm3ParserDURATION-29))|(1<<(qasm3ParserSTRETCH-29))|(1<<(qasm3ParserDURATIONOF-29))|(1<<(qasm3ParserBooleanLiteral-29))|(1<<(qasm3ParserLPAREN-29)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(qasm3ParserMINUS-65))|(1<<(qasm3ParserTILDE-65))|(1<<(qasm3ParserEXCLAMATION_POINT-65))|(1<<(qasm3ParserImaginaryLiteral-65))|(1<<(qasm3ParserBinaryIntegerLiteral-65))|(1<<(qasm3ParserOctalIntegerLiteral-65))|(1<<(qasm3ParserDecimalIntegerLiteral-65))|(1<<(qasm3ParserHexIntegerLiteral-65))|(1<<(qasm3ParserIdentifier-65))|(1<<(qasm3ParserHardwareQubit-65))|(1<<(qasm3ParserFloatLiteral-65))|(1<<(qasm3ParserTimingLiteral-65))|(1<<(qasm3ParserBitstringLiteral-65)))) != 0) {
		{
			p.SetState(529)
			p.expression(0)
		}

	}
	{
		p.SetState(532)
		p.Match(qasm3ParserCOLON)
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(qasm3ParserBOOL-29))|(1<<(qasm3ParserBIT-29))|(1<<(qasm3ParserINT-29))|(1<<(qasm3ParserUINT-29))|(1<<(qasm3ParserFLOAT-29))|(1<<(qasm3ParserANGLE-29))|(1<<(qasm3ParserCOMPLEX-29))|(1<<(qasm3ParserARRAY-29))|(1<<(qasm3ParserDURATION-29))|(1<<(qasm3ParserSTRETCH-29))|(1<<(qasm3ParserDURATIONOF-29))|(1<<(qasm3ParserBooleanLiteral-29))|(1<<(qasm3ParserLPAREN-29)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(qasm3ParserMINUS-65))|(1<<(qasm3ParserTILDE-65))|(1<<(qasm3ParserEXCLAMATION_POINT-65))|(1<<(qasm3ParserImaginaryLiteral-65))|(1<<(qasm3ParserBinaryIntegerLiteral-65))|(1<<(qasm3ParserOctalIntegerLiteral-65))|(1<<(qasm3ParserDecimalIntegerLiteral-65))|(1<<(qasm3ParserHexIntegerLiteral-65))|(1<<(qasm3ParserIdentifier-65))|(1<<(qasm3ParserHardwareQubit-65))|(1<<(qasm3ParserFloatLiteral-65))|(1<<(qasm3ParserTimingLiteral-65))|(1<<(qasm3ParserBitstringLiteral-65)))) != 0) {
		{
			p.SetState(533)
			p.expression(0)
		}

	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOLON {
		{
			p.SetState(536)
			p.Match(qasm3ParserCOLON)
		}
		{
			p.SetState(537)
			p.expression(0)
		}

	}

	return localctx
}

// ISetExpressionContext is an interface to support dynamic dispatch.
type ISetExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetExpressionContext differentiates from other interfaces.
	IsSetExpressionContext()
}

type SetExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExpressionContext() *SetExpressionContext {
	var p = new(SetExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_setExpression
	return p
}

func (*SetExpressionContext) IsSetExpressionContext() {}

func NewSetExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExpressionContext {
	var p = new(SetExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_setExpression

	return p
}

func (s *SetExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *SetExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *SetExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *SetExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *SetExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterSetExpression(s)
	}
}

func (s *SetExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitSetExpression(s)
	}
}

func (s *SetExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitSetExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) SetExpression() (localctx ISetExpressionContext) {
	this := p
	_ = this

	localctx = NewSetExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, qasm3ParserRULE_setExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(540)
		p.Match(qasm3ParserLBRACE)
	}
	{
		p.SetState(541)
		p.expression(0)
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(542)
				p.Match(qasm3ParserCOMMA)
			}
			{
				p.SetState(543)
				p.expression(0)
			}

		}
		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(549)
			p.Match(qasm3ParserCOMMA)
		}

	}
	{
		p.SetState(552)
		p.Match(qasm3ParserRBRACE)
	}

	return localctx
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_arrayLiteral
	return p
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *ArrayLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *ArrayLiteralContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayLiteralContext) AllArrayLiteral() []IArrayLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			len++
		}
	}

	tst := make([]IArrayLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayLiteralContext); ok {
			tst[i] = t.(IArrayLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) ArrayLiteral(i int) IArrayLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *ArrayLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *ArrayLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArrayLiteral() (localctx IArrayLiteralContext) {
	this := p
	_ = this

	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, qasm3ParserRULE_arrayLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.Match(qasm3ParserLBRACE)
	}
	p.SetState(557)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		{
			p.SetState(555)
			p.expression(0)
		}

	case qasm3ParserLBRACE:
		{
			p.SetState(556)
			p.ArrayLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(559)
				p.Match(qasm3ParserCOMMA)
			}
			p.SetState(562)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
				{
					p.SetState(560)
					p.expression(0)
				}

			case qasm3ParserLBRACE:
				{
					p.SetState(561)
					p.ArrayLiteral()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(569)
			p.Match(qasm3ParserCOMMA)
		}

	}
	{
		p.SetState(572)
		p.Match(qasm3ParserRBRACE)
	}

	return localctx
}

// IIndexOperatorContext is an interface to support dynamic dispatch.
type IIndexOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexOperatorContext differentiates from other interfaces.
	IsIndexOperatorContext()
}

type IndexOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOperatorContext() *IndexOperatorContext {
	var p = new(IndexOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_indexOperator
	return p
}

func (*IndexOperatorContext) IsIndexOperatorContext() {}

func NewIndexOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOperatorContext {
	var p = new(IndexOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_indexOperator

	return p
}

func (s *IndexOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOperatorContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *IndexOperatorContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *IndexOperatorContext) SetExpression() ISetExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExpressionContext)
}

func (s *IndexOperatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IndexOperatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexOperatorContext) AllRangeExpression() []IRangeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IRangeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangeExpressionContext); ok {
			tst[i] = t.(IRangeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IndexOperatorContext) RangeExpression(i int) IRangeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *IndexOperatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *IndexOperatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *IndexOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIndexOperator(s)
	}
}

func (s *IndexOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIndexOperator(s)
	}
}

func (s *IndexOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIndexOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IndexOperator() (localctx IIndexOperatorContext) {
	this := p
	_ = this

	localctx = NewIndexOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, qasm3ParserRULE_indexOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(qasm3ParserLBRACKET)
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserLBRACE:
		{
			p.SetState(575)
			p.SetExpression()
		}

	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserCOLON, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(576)
				p.expression(0)
			}

		case 2:
			{
				p.SetState(577)
				p.RangeExpression()
			}

		}
		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(580)
					p.Match(qasm3ParserCOMMA)
				}
				p.SetState(583)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(581)
						p.expression(0)
					}

				case 2:
					{
						p.SetState(582)
						p.RangeExpression()
					}

				}

			}
			p.SetState(589)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
		}
		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserCOMMA {
			{
				p.SetState(590)
				p.Match(qasm3ParserCOMMA)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(595)
		p.Match(qasm3ParserRBRACKET)
	}

	return localctx
}

// IIndexedIdentifierContext is an interface to support dynamic dispatch.
type IIndexedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexedIdentifierContext differentiates from other interfaces.
	IsIndexedIdentifierContext()
}

type IndexedIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexedIdentifierContext() *IndexedIdentifierContext {
	var p = new(IndexedIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_indexedIdentifier
	return p
}

func (*IndexedIdentifierContext) IsIndexedIdentifierContext() {}

func NewIndexedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexedIdentifierContext {
	var p = new(IndexedIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_indexedIdentifier

	return p
}

func (s *IndexedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexedIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *IndexedIdentifierContext) AllIndexOperator() []IIndexOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOperatorContext); ok {
			len++
		}
	}

	tst := make([]IIndexOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOperatorContext); ok {
			tst[i] = t.(IIndexOperatorContext)
			i++
		}
	}

	return tst
}

func (s *IndexedIdentifierContext) IndexOperator(i int) IIndexOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOperatorContext)
}

func (s *IndexedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIndexedIdentifier(s)
	}
}

func (s *IndexedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIndexedIdentifier(s)
	}
}

func (s *IndexedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIndexedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IndexedIdentifier() (localctx IIndexedIdentifierContext) {
	this := p
	_ = this

	localctx = NewIndexedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, qasm3ParserRULE_indexedIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.Match(qasm3ParserIdentifier)
	}
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == qasm3ParserLBRACKET {
		{
			p.SetState(598)
			p.IndexOperator()
		}

		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReturnSignatureContext is an interface to support dynamic dispatch.
type IReturnSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnSignatureContext differentiates from other interfaces.
	IsReturnSignatureContext()
}

type ReturnSignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnSignatureContext() *ReturnSignatureContext {
	var p = new(ReturnSignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_returnSignature
	return p
}

func (*ReturnSignatureContext) IsReturnSignatureContext() {}

func NewReturnSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnSignatureContext {
	var p = new(ReturnSignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_returnSignature

	return p
}

func (s *ReturnSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnSignatureContext) ARROW() antlr.TerminalNode {
	return s.GetToken(qasm3ParserARROW, 0)
}

func (s *ReturnSignatureContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ReturnSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterReturnSignature(s)
	}
}

func (s *ReturnSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitReturnSignature(s)
	}
}

func (s *ReturnSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitReturnSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ReturnSignature() (localctx IReturnSignatureContext) {
	this := p
	_ = this

	localctx = NewReturnSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, qasm3ParserRULE_returnSignature)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.Match(qasm3ParserARROW)
	}
	{
		p.SetState(605)
		p.ScalarType()
	}

	return localctx
}

// IGateModifierContext is an interface to support dynamic dispatch.
type IGateModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGateModifierContext differentiates from other interfaces.
	IsGateModifierContext()
}

type GateModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGateModifierContext() *GateModifierContext {
	var p = new(GateModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateModifier
	return p
}

func (*GateModifierContext) IsGateModifierContext() {}

func NewGateModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateModifierContext {
	var p = new(GateModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateModifier

	return p
}

func (s *GateModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GateModifierContext) AT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserAT, 0)
}

func (s *GateModifierContext) INV() antlr.TerminalNode {
	return s.GetToken(qasm3ParserINV, 0)
}

func (s *GateModifierContext) POW() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPOW, 0)
}

func (s *GateModifierContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *GateModifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GateModifierContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *GateModifierContext) CTRL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCTRL, 0)
}

func (s *GateModifierContext) NEGCTRL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserNEGCTRL, 0)
}

func (s *GateModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateModifier(s)
	}
}

func (s *GateModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateModifier(s)
	}
}

func (s *GateModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateModifier() (localctx IGateModifierContext) {
	this := p
	_ = this

	localctx = NewGateModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, qasm3ParserRULE_gateModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(620)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserINV:
		{
			p.SetState(607)
			p.Match(qasm3ParserINV)
		}

	case qasm3ParserPOW:
		{
			p.SetState(608)
			p.Match(qasm3ParserPOW)
		}
		{
			p.SetState(609)
			p.Match(qasm3ParserLPAREN)
		}
		{
			p.SetState(610)
			p.expression(0)
		}
		{
			p.SetState(611)
			p.Match(qasm3ParserRPAREN)
		}

	case qasm3ParserCTRL, qasm3ParserNEGCTRL:
		{
			p.SetState(613)
			_la = p.GetTokenStream().LA(1)

			if !(_la == qasm3ParserCTRL || _la == qasm3ParserNEGCTRL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLPAREN {
			{
				p.SetState(614)
				p.Match(qasm3ParserLPAREN)
			}
			{
				p.SetState(615)
				p.expression(0)
			}
			{
				p.SetState(616)
				p.Match(qasm3ParserRPAREN)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(622)
		p.Match(qasm3ParserAT)
	}

	return localctx
}

// IScalarTypeContext is an interface to support dynamic dispatch.
type IScalarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalarTypeContext differentiates from other interfaces.
	IsScalarTypeContext()
}

type ScalarTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarTypeContext() *ScalarTypeContext {
	var p = new(ScalarTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_scalarType
	return p
}

func (*ScalarTypeContext) IsScalarTypeContext() {}

func NewScalarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarTypeContext {
	var p = new(ScalarTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_scalarType

	return p
}

func (s *ScalarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarTypeContext) BIT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBIT, 0)
}

func (s *ScalarTypeContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *ScalarTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserINT, 0)
}

func (s *ScalarTypeContext) UINT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserUINT, 0)
}

func (s *ScalarTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserFLOAT, 0)
}

func (s *ScalarTypeContext) ANGLE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserANGLE, 0)
}

func (s *ScalarTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBOOL, 0)
}

func (s *ScalarTypeContext) DURATION() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDURATION, 0)
}

func (s *ScalarTypeContext) STRETCH() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSTRETCH, 0)
}

func (s *ScalarTypeContext) COMPLEX() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMPLEX, 0)
}

func (s *ScalarTypeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *ScalarTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ScalarTypeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *ScalarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterScalarType(s)
	}
}

func (s *ScalarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitScalarType(s)
	}
}

func (s *ScalarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitScalarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ScalarType() (localctx IScalarTypeContext) {
	this := p
	_ = this

	localctx = NewScalarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, qasm3ParserRULE_scalarType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(654)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(624)
			p.Match(qasm3ParserBIT)
		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(625)
				p.Designator()
			}

		}

	case qasm3ParserINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(628)
			p.Match(qasm3ParserINT)
		}
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(629)
				p.Designator()
			}

		}

	case qasm3ParserUINT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(632)
			p.Match(qasm3ParserUINT)
		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(633)
				p.Designator()
			}

		}

	case qasm3ParserFLOAT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(636)
			p.Match(qasm3ParserFLOAT)
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(637)
				p.Designator()
			}

		}

	case qasm3ParserANGLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(640)
			p.Match(qasm3ParserANGLE)
		}
		p.SetState(642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(641)
				p.Designator()
			}

		}

	case qasm3ParserBOOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(644)
			p.Match(qasm3ParserBOOL)
		}

	case qasm3ParserDURATION:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(645)
			p.Match(qasm3ParserDURATION)
		}

	case qasm3ParserSTRETCH:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(646)
			p.Match(qasm3ParserSTRETCH)
		}

	case qasm3ParserCOMPLEX:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(647)
			p.Match(qasm3ParserCOMPLEX)
		}
		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(648)
				p.Match(qasm3ParserLBRACKET)
			}
			{
				p.SetState(649)
				p.ScalarType()
			}
			{
				p.SetState(650)
				p.Match(qasm3ParserRBRACKET)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQubitTypeContext is an interface to support dynamic dispatch.
type IQubitTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQubitTypeContext differentiates from other interfaces.
	IsQubitTypeContext()
}

type QubitTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQubitTypeContext() *QubitTypeContext {
	var p = new(QubitTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_qubitType
	return p
}

func (*QubitTypeContext) IsQubitTypeContext() {}

func NewQubitTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QubitTypeContext {
	var p = new(QubitTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_qubitType

	return p
}

func (s *QubitTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *QubitTypeContext) QUBIT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserQUBIT, 0)
}

func (s *QubitTypeContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *QubitTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QubitTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QubitTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterQubitType(s)
	}
}

func (s *QubitTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitQubitType(s)
	}
}

func (s *QubitTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitQubitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) QubitType() (localctx IQubitTypeContext) {
	this := p
	_ = this

	localctx = NewQubitTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, qasm3ParserRULE_qubitType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(qasm3ParserQUBIT)
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLBRACKET {
		{
			p.SetState(657)
			p.Designator()
		}

	}

	return localctx
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_arrayType
	return p
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(qasm3ParserARRAY, 0)
}

func (s *ArrayTypeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *ArrayTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArrayTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, 0)
}

func (s *ArrayTypeContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayTypeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArrayType() (localctx IArrayTypeContext) {
	this := p
	_ = this

	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, qasm3ParserRULE_arrayType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(qasm3ParserARRAY)
	}
	{
		p.SetState(661)
		p.Match(qasm3ParserLBRACKET)
	}
	{
		p.SetState(662)
		p.ScalarType()
	}
	{
		p.SetState(663)
		p.Match(qasm3ParserCOMMA)
	}
	{
		p.SetState(664)
		p.ExpressionList()
	}
	{
		p.SetState(665)
		p.Match(qasm3ParserRBRACKET)
	}

	return localctx
}

// IArrayReferenceTypeContext is an interface to support dynamic dispatch.
type IArrayReferenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayReferenceTypeContext differentiates from other interfaces.
	IsArrayReferenceTypeContext()
}

type ArrayReferenceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayReferenceTypeContext() *ArrayReferenceTypeContext {
	var p = new(ArrayReferenceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_arrayReferenceType
	return p
}

func (*ArrayReferenceTypeContext) IsArrayReferenceTypeContext() {}

func NewArrayReferenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayReferenceTypeContext {
	var p = new(ArrayReferenceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_arrayReferenceType

	return p
}

func (s *ArrayReferenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayReferenceTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(qasm3ParserARRAY, 0)
}

func (s *ArrayReferenceTypeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *ArrayReferenceTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArrayReferenceTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, 0)
}

func (s *ArrayReferenceTypeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *ArrayReferenceTypeContext) CONST() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCONST, 0)
}

func (s *ArrayReferenceTypeContext) MUTABLE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMUTABLE, 0)
}

func (s *ArrayReferenceTypeContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayReferenceTypeContext) DIM() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDIM, 0)
}

func (s *ArrayReferenceTypeContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *ArrayReferenceTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayReferenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayReferenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayReferenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArrayReferenceType(s)
	}
}

func (s *ArrayReferenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArrayReferenceType(s)
	}
}

func (s *ArrayReferenceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArrayReferenceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArrayReferenceType() (localctx IArrayReferenceTypeContext) {
	this := p
	_ = this

	localctx = NewArrayReferenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, qasm3ParserRULE_arrayReferenceType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserCONST || _la == qasm3ParserMUTABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(668)
		p.Match(qasm3ParserARRAY)
	}
	{
		p.SetState(669)
		p.Match(qasm3ParserLBRACKET)
	}
	{
		p.SetState(670)
		p.ScalarType()
	}
	{
		p.SetState(671)
		p.Match(qasm3ParserCOMMA)
	}
	p.SetState(676)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		{
			p.SetState(672)
			p.ExpressionList()
		}

	case qasm3ParserDIM:
		{
			p.SetState(673)
			p.Match(qasm3ParserDIM)
		}
		{
			p.SetState(674)
			p.Match(qasm3ParserEQUALS)
		}
		{
			p.SetState(675)
			p.expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(678)
		p.Match(qasm3ParserRBRACKET)
	}

	return localctx
}

// IDesignatorContext is an interface to support dynamic dispatch.
type IDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignatorContext differentiates from other interfaces.
	IsDesignatorContext()
}

type DesignatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorContext() *DesignatorContext {
	var p = new(DesignatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_designator
	return p
}

func (*DesignatorContext) IsDesignatorContext() {}

func NewDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorContext {
	var p = new(DesignatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_designator

	return p
}

func (s *DesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *DesignatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DesignatorContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *DesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDesignator(s)
	}
}

func (s *DesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDesignator(s)
	}
}

func (s *DesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Designator() (localctx IDesignatorContext) {
	this := p
	_ = this

	localctx = NewDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, qasm3ParserRULE_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(qasm3ParserLBRACKET)
	}
	{
		p.SetState(681)
		p.expression(0)
	}
	{
		p.SetState(682)
		p.Match(qasm3ParserRBRACKET)
	}

	return localctx
}

// IDefcalTargetContext is an interface to support dynamic dispatch.
type IDefcalTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefcalTargetContext differentiates from other interfaces.
	IsDefcalTargetContext()
}

type DefcalTargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalTargetContext() *DefcalTargetContext {
	var p = new(DefcalTargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalTarget
	return p
}

func (*DefcalTargetContext) IsDefcalTargetContext() {}

func NewDefcalTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalTargetContext {
	var p = new(DefcalTargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalTarget

	return p
}

func (s *DefcalTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalTargetContext) MEASURE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMEASURE, 0)
}

func (s *DefcalTargetContext) RESET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRESET, 0)
}

func (s *DefcalTargetContext) DELAY() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDELAY, 0)
}

func (s *DefcalTargetContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *DefcalTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalTarget(s)
	}
}

func (s *DefcalTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalTarget(s)
	}
}

func (s *DefcalTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalTarget() (localctx IDefcalTargetContext) {
	this := p
	_ = this

	localctx = NewDefcalTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, qasm3ParserRULE_defcalTarget)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(qasm3ParserDELAY-46))|(1<<(qasm3ParserRESET-46))|(1<<(qasm3ParserMEASURE-46)))) != 0) || _la == qasm3ParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDefcalArgumentDefinitionContext is an interface to support dynamic dispatch.
type IDefcalArgumentDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefcalArgumentDefinitionContext differentiates from other interfaces.
	IsDefcalArgumentDefinitionContext()
}

type DefcalArgumentDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalArgumentDefinitionContext() *DefcalArgumentDefinitionContext {
	var p = new(DefcalArgumentDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinition
	return p
}

func (*DefcalArgumentDefinitionContext) IsDefcalArgumentDefinitionContext() {}

func NewDefcalArgumentDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalArgumentDefinitionContext {
	var p = new(DefcalArgumentDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinition

	return p
}

func (s *DefcalArgumentDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalArgumentDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefcalArgumentDefinitionContext) ArgumentDefinition() IArgumentDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentDefinitionContext)
}

func (s *DefcalArgumentDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalArgumentDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalArgumentDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalArgumentDefinition(s)
	}
}

func (s *DefcalArgumentDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalArgumentDefinition(s)
	}
}

func (s *DefcalArgumentDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalArgumentDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalArgumentDefinition() (localctx IDefcalArgumentDefinitionContext) {
	this := p
	_ = this

	localctx = NewDefcalArgumentDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, qasm3ParserRULE_defcalArgumentDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(686)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(687)
			p.ArgumentDefinition()
		}

	}

	return localctx
}

// IDefcalOperandContext is an interface to support dynamic dispatch.
type IDefcalOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefcalOperandContext differentiates from other interfaces.
	IsDefcalOperandContext()
}

type DefcalOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalOperandContext() *DefcalOperandContext {
	var p = new(DefcalOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalOperand
	return p
}

func (*DefcalOperandContext) IsDefcalOperandContext() {}

func NewDefcalOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalOperandContext {
	var p = new(DefcalOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalOperand

	return p
}

func (s *DefcalOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalOperandContext) HardwareQubit() antlr.TerminalNode {
	return s.GetToken(qasm3ParserHardwareQubit, 0)
}

func (s *DefcalOperandContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *DefcalOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalOperand(s)
	}
}

func (s *DefcalOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalOperand(s)
	}
}

func (s *DefcalOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalOperand() (localctx IDefcalOperandContext) {
	this := p
	_ = this

	localctx = NewDefcalOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, qasm3ParserRULE_defcalOperand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserIdentifier || _la == qasm3ParserHardwareQubit) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGateOperandContext is an interface to support dynamic dispatch.
type IGateOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGateOperandContext differentiates from other interfaces.
	IsGateOperandContext()
}

type GateOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGateOperandContext() *GateOperandContext {
	var p = new(GateOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateOperand
	return p
}

func (*GateOperandContext) IsGateOperandContext() {}

func NewGateOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateOperandContext {
	var p = new(GateOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateOperand

	return p
}

func (s *GateOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *GateOperandContext) IndexedIdentifier() IIndexedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexedIdentifierContext)
}

func (s *GateOperandContext) HardwareQubit() antlr.TerminalNode {
	return s.GetToken(qasm3ParserHardwareQubit, 0)
}

func (s *GateOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateOperand(s)
	}
}

func (s *GateOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateOperand(s)
	}
}

func (s *GateOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateOperand() (localctx IGateOperandContext) {
	this := p
	_ = this

	localctx = NewGateOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, qasm3ParserRULE_gateOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(694)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(692)
			p.IndexedIdentifier()
		}

	case qasm3ParserHardwareQubit:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(693)
			p.Match(qasm3ParserHardwareQubit)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExternArgumentContext is an interface to support dynamic dispatch.
type IExternArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternArgumentContext differentiates from other interfaces.
	IsExternArgumentContext()
}

type ExternArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternArgumentContext() *ExternArgumentContext {
	var p = new(ExternArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_externArgument
	return p
}

func (*ExternArgumentContext) IsExternArgumentContext() {}

func NewExternArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternArgumentContext {
	var p = new(ExternArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_externArgument

	return p
}

func (s *ExternArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternArgumentContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ExternArgumentContext) ArrayReferenceType() IArrayReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayReferenceTypeContext)
}

func (s *ExternArgumentContext) CREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCREG, 0)
}

func (s *ExternArgumentContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *ExternArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExternArgument(s)
	}
}

func (s *ExternArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExternArgument(s)
	}
}

func (s *ExternArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExternArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExternArgument() (localctx IExternArgumentContext) {
	this := p
	_ = this

	localctx = NewExternArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, qasm3ParserRULE_externArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(702)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(696)
			p.ScalarType()
		}

	case qasm3ParserCONST, qasm3ParserMUTABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(697)
			p.ArrayReferenceType()
		}

	case qasm3ParserCREG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(698)
			p.Match(qasm3ParserCREG)
		}
		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(699)
				p.Designator()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentDefinitionContext is an interface to support dynamic dispatch.
type IArgumentDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentDefinitionContext differentiates from other interfaces.
	IsArgumentDefinitionContext()
}

type ArgumentDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentDefinitionContext() *ArgumentDefinitionContext {
	var p = new(ArgumentDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_argumentDefinition
	return p
}

func (*ArgumentDefinitionContext) IsArgumentDefinitionContext() {}

func NewArgumentDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentDefinitionContext {
	var p = new(ArgumentDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_argumentDefinition

	return p
}

func (s *ArgumentDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentDefinitionContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArgumentDefinitionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *ArgumentDefinitionContext) QubitType() IQubitTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQubitTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQubitTypeContext)
}

func (s *ArgumentDefinitionContext) CREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCREG, 0)
}

func (s *ArgumentDefinitionContext) QREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserQREG, 0)
}

func (s *ArgumentDefinitionContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *ArgumentDefinitionContext) ArrayReferenceType() IArrayReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayReferenceTypeContext)
}

func (s *ArgumentDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArgumentDefinition(s)
	}
}

func (s *ArgumentDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArgumentDefinition(s)
	}
}

func (s *ArgumentDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArgumentDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArgumentDefinition() (localctx IArgumentDefinitionContext) {
	this := p
	_ = this

	localctx = NewArgumentDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, qasm3ParserRULE_argumentDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(718)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(704)
			p.ScalarType()
		}
		{
			p.SetState(705)
			p.Match(qasm3ParserIdentifier)
		}

	case qasm3ParserQUBIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(707)
			p.QubitType()
		}
		{
			p.SetState(708)
			p.Match(qasm3ParserIdentifier)
		}

	case qasm3ParserQREG, qasm3ParserCREG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(710)
			_la = p.GetTokenStream().LA(1)

			if !(_la == qasm3ParserQREG || _la == qasm3ParserCREG) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(711)
			p.Match(qasm3ParserIdentifier)
		}
		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(712)
				p.Designator()
			}

		}

	case qasm3ParserCONST, qasm3ParserMUTABLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(715)
			p.ArrayReferenceType()
		}
		{
			p.SetState(716)
			p.Match(qasm3ParserIdentifier)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentDefinitionListContext is an interface to support dynamic dispatch.
type IArgumentDefinitionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentDefinitionListContext differentiates from other interfaces.
	IsArgumentDefinitionListContext()
}

type ArgumentDefinitionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentDefinitionListContext() *ArgumentDefinitionListContext {
	var p = new(ArgumentDefinitionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_argumentDefinitionList
	return p
}

func (*ArgumentDefinitionListContext) IsArgumentDefinitionListContext() {}

func NewArgumentDefinitionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentDefinitionListContext {
	var p = new(ArgumentDefinitionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_argumentDefinitionList

	return p
}

func (s *ArgumentDefinitionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentDefinitionListContext) AllArgumentDefinition() []IArgumentDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IArgumentDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentDefinitionContext); ok {
			tst[i] = t.(IArgumentDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentDefinitionListContext) ArgumentDefinition(i int) IArgumentDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentDefinitionContext)
}

func (s *ArgumentDefinitionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *ArgumentDefinitionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *ArgumentDefinitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentDefinitionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentDefinitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArgumentDefinitionList(s)
	}
}

func (s *ArgumentDefinitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArgumentDefinitionList(s)
	}
}

func (s *ArgumentDefinitionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArgumentDefinitionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArgumentDefinitionList() (localctx IArgumentDefinitionListContext) {
	this := p
	_ = this

	localctx = NewArgumentDefinitionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, qasm3ParserRULE_argumentDefinitionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.ArgumentDefinition()
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(721)
				p.Match(qasm3ParserCOMMA)
			}
			{
				p.SetState(722)
				p.ArgumentDefinition()
			}

		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
	}
	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(728)
			p.Match(qasm3ParserCOMMA)
		}

	}

	return localctx
}

// IDefcalArgumentDefinitionListContext is an interface to support dynamic dispatch.
type IDefcalArgumentDefinitionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefcalArgumentDefinitionListContext differentiates from other interfaces.
	IsDefcalArgumentDefinitionListContext()
}

type DefcalArgumentDefinitionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalArgumentDefinitionListContext() *DefcalArgumentDefinitionListContext {
	var p = new(DefcalArgumentDefinitionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinitionList
	return p
}

func (*DefcalArgumentDefinitionListContext) IsDefcalArgumentDefinitionListContext() {}

func NewDefcalArgumentDefinitionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalArgumentDefinitionListContext {
	var p = new(DefcalArgumentDefinitionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinitionList

	return p
}

func (s *DefcalArgumentDefinitionListContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalArgumentDefinitionListContext) AllDefcalArgumentDefinition() []IDefcalArgumentDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDefcalArgumentDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IDefcalArgumentDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDefcalArgumentDefinitionContext); ok {
			tst[i] = t.(IDefcalArgumentDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *DefcalArgumentDefinitionListContext) DefcalArgumentDefinition(i int) IDefcalArgumentDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalArgumentDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalArgumentDefinitionContext)
}

func (s *DefcalArgumentDefinitionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *DefcalArgumentDefinitionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *DefcalArgumentDefinitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalArgumentDefinitionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalArgumentDefinitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalArgumentDefinitionList(s)
	}
}

func (s *DefcalArgumentDefinitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalArgumentDefinitionList(s)
	}
}

func (s *DefcalArgumentDefinitionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalArgumentDefinitionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalArgumentDefinitionList() (localctx IDefcalArgumentDefinitionListContext) {
	this := p
	_ = this

	localctx = NewDefcalArgumentDefinitionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, qasm3ParserRULE_defcalArgumentDefinitionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.DefcalArgumentDefinition()
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(732)
				p.Match(qasm3ParserCOMMA)
			}
			{
				p.SetState(733)
				p.DefcalArgumentDefinition()
			}

		}
		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
	}
	p.SetState(740)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(739)
			p.Match(qasm3ParserCOMMA)
		}

	}

	return localctx
}

// IDefcalOperandListContext is an interface to support dynamic dispatch.
type IDefcalOperandListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefcalOperandListContext differentiates from other interfaces.
	IsDefcalOperandListContext()
}

type DefcalOperandListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalOperandListContext() *DefcalOperandListContext {
	var p = new(DefcalOperandListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalOperandList
	return p
}

func (*DefcalOperandListContext) IsDefcalOperandListContext() {}

func NewDefcalOperandListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalOperandListContext {
	var p = new(DefcalOperandListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalOperandList

	return p
}

func (s *DefcalOperandListContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalOperandListContext) AllDefcalOperand() []IDefcalOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDefcalOperandContext); ok {
			len++
		}
	}

	tst := make([]IDefcalOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDefcalOperandContext); ok {
			tst[i] = t.(IDefcalOperandContext)
			i++
		}
	}

	return tst
}

func (s *DefcalOperandListContext) DefcalOperand(i int) IDefcalOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalOperandContext)
}

func (s *DefcalOperandListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *DefcalOperandListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *DefcalOperandListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalOperandListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalOperandListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalOperandList(s)
	}
}

func (s *DefcalOperandListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalOperandList(s)
	}
}

func (s *DefcalOperandListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalOperandList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalOperandList() (localctx IDefcalOperandListContext) {
	this := p
	_ = this

	localctx = NewDefcalOperandListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, qasm3ParserRULE_defcalOperandList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(742)
		p.DefcalOperand()
	}
	p.SetState(747)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(743)
				p.Match(qasm3ParserCOMMA)
			}
			{
				p.SetState(744)
				p.DefcalOperand()
			}

		}
		p.SetState(749)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())
	}
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(750)
			p.Match(qasm3ParserCOMMA)
		}

	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, qasm3ParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(753)
		p.expression(0)
	}
	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(754)
				p.Match(qasm3ParserCOMMA)
			}
			{
				p.SetState(755)
				p.expression(0)
			}

		}
		p.SetState(760)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())
	}
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(761)
			p.Match(qasm3ParserCOMMA)
		}

	}

	return localctx
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_identifierList
	return p
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserIdentifier)
}

func (s *IdentifierListContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, i)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IdentifierList() (localctx IIdentifierListContext) {
	this := p
	_ = this

	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, qasm3ParserRULE_identifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.Match(qasm3ParserIdentifier)
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(765)
				p.Match(qasm3ParserCOMMA)
			}
			{
				p.SetState(766)
				p.Match(qasm3ParserIdentifier)
			}

		}
		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(772)
			p.Match(qasm3ParserCOMMA)
		}

	}

	return localctx
}

// IGateOperandListContext is an interface to support dynamic dispatch.
type IGateOperandListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGateOperandListContext differentiates from other interfaces.
	IsGateOperandListContext()
}

type GateOperandListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGateOperandListContext() *GateOperandListContext {
	var p = new(GateOperandListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateOperandList
	return p
}

func (*GateOperandListContext) IsGateOperandListContext() {}

func NewGateOperandListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateOperandListContext {
	var p = new(GateOperandListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateOperandList

	return p
}

func (s *GateOperandListContext) GetParser() antlr.Parser { return s.parser }

func (s *GateOperandListContext) AllGateOperand() []IGateOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGateOperandContext); ok {
			len++
		}
	}

	tst := make([]IGateOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGateOperandContext); ok {
			tst[i] = t.(IGateOperandContext)
			i++
		}
	}

	return tst
}

func (s *GateOperandListContext) GateOperand(i int) IGateOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandContext)
}

func (s *GateOperandListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *GateOperandListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *GateOperandListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateOperandListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateOperandListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateOperandList(s)
	}
}

func (s *GateOperandListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateOperandList(s)
	}
}

func (s *GateOperandListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateOperandList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateOperandList() (localctx IGateOperandListContext) {
	this := p
	_ = this

	localctx = NewGateOperandListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, qasm3ParserRULE_gateOperandList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.GateOperand()
	}
	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(776)
				p.Match(qasm3ParserCOMMA)
			}
			{
				p.SetState(777)
				p.GateOperand()
			}

		}
		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(783)
			p.Match(qasm3ParserCOMMA)
		}

	}

	return localctx
}

// IExternArgumentListContext is an interface to support dynamic dispatch.
type IExternArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternArgumentListContext differentiates from other interfaces.
	IsExternArgumentListContext()
}

type ExternArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternArgumentListContext() *ExternArgumentListContext {
	var p = new(ExternArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = qasm3ParserRULE_externArgumentList
	return p
}

func (*ExternArgumentListContext) IsExternArgumentListContext() {}

func NewExternArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternArgumentListContext {
	var p = new(ExternArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_externArgumentList

	return p
}

func (s *ExternArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternArgumentListContext) AllExternArgument() []IExternArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternArgumentContext); ok {
			len++
		}
	}

	tst := make([]IExternArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternArgumentContext); ok {
			tst[i] = t.(IExternArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ExternArgumentListContext) ExternArgument(i int) IExternArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternArgumentContext)
}

func (s *ExternArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *ExternArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *ExternArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExternArgumentList(s)
	}
}

func (s *ExternArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExternArgumentList(s)
	}
}

func (s *ExternArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExternArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExternArgumentList() (localctx IExternArgumentListContext) {
	this := p
	_ = this

	localctx = NewExternArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, qasm3ParserRULE_externArgumentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.ExternArgument()
	}
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(787)
				p.Match(qasm3ParserCOMMA)
			}
			{
				p.SetState(788)
				p.ExternArgument()
			}

		}
		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())
	}
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(794)
			p.Match(qasm3ParserCOMMA)
		}

	}

	return localctx
}

func (p *qasm3Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 35:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *qasm3Parser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 17)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
